{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Frequenz Electricity Trading API Client","text":""},{"location":"#introduction","title":"Introduction","text":"<p>Electricity Trading API client for Python The Frequenz Electricity Trading API client for Python is an easy-to-use Python interface built to interact with the Frequenz Electricity Trading API. It allows you to create orders, get market data, and manage your orders.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Create and manage gridpool orders: Place new orders, update existing ones, and cancel orders when necessary.</li> <li>Stream live data: Get real-time updates on market data, including order books, trades, and market prices.</li> <li>Retrieve historical data: Access historical data on market trades.</li> </ul>"},{"location":"#supported-platforms","title":"Supported Platforms","text":"<p>The following platforms are officially supported (tested):</p> <ul> <li>Python: 3.11</li> <li>Operating System: Ubuntu Linux 20.04</li> <li>Architectures: amd64, arm64</li> </ul>"},{"location":"#usage","title":"Usage","text":""},{"location":"#installation","title":"Installation","text":"<p>We assume you are on a system with Python available. If that is not the case, please download and install Python first.</p> <p>To install the Frequenz Electricity Trading AP, you probably want to create a new virtual environment first. For example, if you use a <code>sh</code> compatible shell, you can do this:</p> <pre><code>python3 -m venv .venv\n. .venv/bin/activate\n</code></pre> <p>Then, just install using <code>pip</code>. Replace <code>VERSION</code> with the specific version you wish to install:</p> <pre><code># Choose the version you want to install\nVERSION=0.2.3\npip install frequenz-client-electricity-trading==$VERSION\n</code></pre>"},{"location":"#documentation","title":"Documentation","text":"<p>For more information, please visit the documentation website.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>If you want to know how to build this project and contribute to it, please check out the Contributing Guide.</p>"},{"location":"CONTRIBUTING/","title":"Contributing to Frequenz Electricity Trading API Client","text":""},{"location":"CONTRIBUTING/#build","title":"Build","text":"<p>You can use <code>build</code> to simply build the source and binary distribution:</p> <pre><code>python -m pip install build\npython -m build\n</code></pre>"},{"location":"CONTRIBUTING/#local-development","title":"Local development","text":"<p>You can use editable installs to develop the project locally (it will install all the dependencies too):</p> <pre><code>python -m pip install -e .\n</code></pre> <p>Or you can install all development dependencies (<code>mypy</code>, <code>pylint</code>, <code>pytest</code>, etc.) in one go too: <pre><code>python -m pip install -e .[dev]\n</code></pre></p> <p>If you don't want to install all the dependencies, you can also use <code>nox</code> to run the tests and other checks creating its own virtual environments:</p> <pre><code>python -m pip install .[dev-noxfile]\nnox\n</code></pre> <p>You can also use <code>nox -R</code> to reuse the current testing environment to speed up test at the expense of a higher chance to end up with a dirty test environment.</p>"},{"location":"CONTRIBUTING/#running-tests-checks-individually","title":"Running tests / checks individually","text":"<p>For a better development test cycle you can install the runtime and test dependencies and run <code>pytest</code> manually.</p> <pre><code>python -m pip install .[dev-pytest]  # included in .[dev] too\n\n# And for example\npytest tests/test_*.py\n</code></pre> <p>Or you can use <code>nox</code>:</p> <pre><code>nox -R -s pytest -- test/test_*.py\n</code></pre> <p>The same appliest to <code>pylint</code> or <code>mypy</code> for example:</p> <pre><code>nox -R -s pylint -- test/test_*.py\nnox -R -s mypy -- test/test_*.py\n</code></pre>"},{"location":"CONTRIBUTING/#building-the-documentation","title":"Building the documentation","text":"<p>To build the documentation, first install the dependencies (if you didn't install all <code>dev</code> dependencies):</p> <pre><code>python -m pip install -e .[dev-mkdocs]\n</code></pre> <p>Then you can build the documentation (it will be written in the <code>site/</code> directory):</p> <pre><code>mkdocs build\n</code></pre> <p>Or you can just serve the documentation without building it using:</p> <pre><code>mkdocs serve\n</code></pre> <p>Your site will be updated live when you change your files (provided that you used <code>pip install -e .</code>, beware of a common pitfall of using <code>pip install</code> without <code>-e</code>, in that case the API reference won't change unless you do a new <code>pip install</code>).</p> <p>To build multi-version documentation, we use mike. If you want to see how the multi-version sites looks like locally, you can use:</p> <pre><code>mike deploy my-version\nmike set-default my-version\nmike serve\n</code></pre> <p><code>mike</code> works in mysterious ways. Some basic information:</p> <ul> <li><code>mike deploy</code> will do a <code>mike build</code> and write the results to your local <code>gh-pages</code> branch. <code>my-version</code> is an arbitrary name for the local version   you want to preview.</li> <li><code>mike set-default</code> is needed so when you serve the documentation, it goes to   your newly produced documentation by default.</li> <li><code>mike serve</code> will serve the contents of your local <code>gh-pages</code> branch. Be   aware that, unlike <code>mkdocs serve</code>, changes to the sources won't be shown   live, as the <code>mike deploy</code> step is needed to refresh them.</li> </ul> <p>Be careful not to use <code>--push</code> with <code>mike deploy</code>, otherwise it will push your local <code>gh-pages</code> branch to the <code>origin</code> remote.</p> <p>That said, if you want to test the actual website in your fork, you can always use <code>mike deploy --push --remote your-fork-remote</code>, and then access the GitHub pages produced for your fork.</p>"},{"location":"CONTRIBUTING/#releasing","title":"Releasing","text":"<p>These are the steps to create a new release:</p> <ol> <li> <p>Get the latest head you want to create a release from.</p> </li> <li> <p>Update the <code>RELEASE_NOTES.md</code> file if it is not complete, up to date, and    remove template comments (<code>&lt;!-- ... -&gt;</code>) and empty sections. Submit a pull    request if an update is needed, wait until it is merged, and update the    latest head you want to create a release from to get the new merged pull    request.</p> </li> <li> <p>Create a new signed tag using the release notes and    a semver compatible version number with a <code>v</code> prefix,    for example:</p> </li> </ol> <pre><code>git tag -s --cleanup=whitespace -F RELEASE_NOTES.md v0.0.1\n</code></pre> <ol> <li> <p>Push the new tag.</p> </li> <li> <p>A GitHub action will test the tag and if all goes well it will create    a GitHub    Release,    and upload a new package to    PyPI    automatically.</p> </li> <li> <p>Once this is done, reset the <code>RELEASE_NOTES.md</code> with the template:</p> </li> </ol> <pre><code>cp .github/RELEASE_NOTES.template.md RELEASE_NOTES.md\n</code></pre> <p>Commit the new release notes and create a PR (this step should be automated    eventually too).</p> <ol> <li>Celebrate!</li> </ol>"},{"location":"CONTRIBUTING/#cross-arch-testing","title":"Cross-Arch Testing","text":"<p>This project has built-in support for testing across multiple architectures. Currently, our CI conducts tests on <code>arm64</code> machines using QEMU emulation. We also have the flexibility to expand this support to include additional architectures in the future.</p> <p>This project contains Dockerfiles that can be used in the CI to test the python package in non-native machine architectures, e.g., <code>arm64</code>. The Dockerfiles exist in the directory <code>.github/containers/nox-cross-arch</code>, and follow a naming scheme so that they can be easily used in build matrices in the CI, in <code>nox-cross-arch</code> job. The naming scheme is:</p> <pre><code>&lt;arch&gt;-&lt;os&gt;-python-&lt;python-version&gt;.Dockerfile\n</code></pre> <p>E.g.,</p> <pre><code>arm64-ubuntu-20.04-python-3.11.Dockerfile\n</code></pre> <p>If a Dockerfile for your desired target architecture, OS, and python version does not exist here, please add one before proceeding to add your options to the test matrix.</p>"},{"location":"SUMMARY/","title":"SUMMARY","text":"<ul> <li>Home</li> <li>API Reference</li> <li>Contributing</li> </ul>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>frequenz<ul> <li>client<ul> <li>electricity_trading<ul> <li>cli<ul> <li>day_ahead</li> <li>etrading</li> </ul> </li> </ul> </li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/frequenz/client/electricity_trading/","title":"Index","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading","title":"frequenz.client.electricity_trading","text":"<p>Electricity Trading API client for Python.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading--frequenz-electricity-trading-api-client","title":"Frequenz Electricity Trading API Client","text":"<p>This module provides an easy-to-use Python interface to interact with the Frequenz Electricity Trading API. It allows you to create orders, manage market data, and interact with the electricity trading ecosystem.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading--features","title":"Features","text":"<ul> <li>Create and manage gridpool orders: Place new orders, update existing ones, and cancel orders when necessary.</li> <li>Stream live data: Get real-time updates on market data, including order books, trades, and market prices.</li> <li>Retrieve historical data: Access historical data on market trades.</li> </ul>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading--installation","title":"Installation","text":"<p>You can install the Frequenz Electricity Trading API client via pip. Replace <code>VERSION</code> with the specific version you wish to install.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading--choose-the-version-you-want-to-install","title":"Choose the version you want to install","text":"<pre><code>VERSION=0.2.5\npip install frequenz-client-electricity-trading==$VERSION\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading--initialization","title":"Initialization","text":"<p>First, initialize the client with the appropriate server URL and API key.</p> Initialize the client <pre><code>import asyncio\nfrom frequenz.client.electricity_trading import Client\n\n# Change server address if needed\nSERVICE_URL = \"grpc://electricity-trading.api.frequenz.com:443?ssl=true\"\nwith open('/path/to/api_key.txt', 'r', encoding='utf-8') as f:\n    API_KEY = f.read().strip()\n\nasync def initialize():\n    client = Client(\n        server_url=SERVICE_URL,\n        auth_key=API_KEY\n    )\n\nasyncio.run(initialize())\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading--example-usage","title":"Example Usage","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading--create-an-order","title":"Create an Order","text":"<p>Here's an example of how to create a limit order to buy energy.</p> Create a limit order <pre><code>import asyncio\nfrom frequenz.client.electricity_trading import (\n    Client,\n    Currency,\n    DeliveryArea,\n    DeliveryPeriod,\n    EnergyMarketCodeType,\n    MarketSide,\n    OrderType,\n    Power,\n    Price,\n)\nfrom datetime import datetime, timedelta\nfrom decimal import Decimal\n\n# Change server address if needed\nSERVICE_URL = \"grpc://electricity-trading.api.frequenz.com:443?ssl=true\"\nwith open('/path/to/api_key.txt', 'r', encoding='utf-8') as f:\n    API_KEY = f.read().strip()\n\nasync def create_order():\n    client = Client(\n        server_url=SERVICE_URL,\n        auth_key=API_KEY\n    )\n\n    # Define order parameters\n    gridpool_id = 1\n    delivery_area = DeliveryArea(\n        code=\"10YDE-EON------1\",  # TenneT\n        code_type=EnergyMarketCodeType.EUROPE_EIC\n    )\n    delivery_period = DeliveryPeriod(\n        start=datetime.fromisoformat(\"2024-05-01T00:00:00+00:00\"),\n        duration=timedelta(minutes=15)\n    )\n    price = Price(amount=Decimal(\"50.0\"), currency=Currency.EUR)\n    quantity = Power(mw=Decimal(\"0.1\"))\n    order = await client.create_gridpool_order(\n        gridpool_id=gridpool_id,\n        delivery_area=delivery_area,\n        delivery_period=delivery_period,\n        order_type=OrderType.LIMIT,\n        side=MarketSide.BUY,\n        price=price,\n        quantity=quantity,\n    )\n\nasyncio.run(create_order())\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading--list-orders-for-a-gridpool","title":"List Orders for a Gridpool","text":"<p>Orders for a given gridpool can be listed using various filters.</p> List orders for a gridpool <pre><code>import asyncio\nfrom frequenz.client.electricity_trading import ( Client, MarketSide )\n\n# Change server address if needed\nSERVICE_URL = \"grpc://electricity-trading.api.frequenz.com:443?ssl=true\"\nwith open('/path/to/api_key.txt', 'r', encoding='utf-8') as f:\n    API_KEY = f.read().strip()\n\nasync def list_orders():\n    client = Client(\n        server_url=SERVICE_URL,\n        auth_key=API_KEY\n    )\n\n    gridpool_id: int = 1\n\n    # List all orders for a given gridpool\n    orders = await client.list_gridpool_orders(\n        gridpool_id=gridpool_id,\n    )\n\n    # List only the buy orders for a given gridpool\n    buy_orders = await client.list_gridpool_orders(\n        gridpool_id=gridpool_id,\n        side=MarketSide.BUY,\n    )\n\nasyncio.run(list_orders())\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading--streaming-public-trades","title":"Streaming Public Trades","text":"<p>To get real-time updates on market trades, use the following code:</p> Stream public trades <pre><code>import asyncio\nfrom frequenz.client.electricity_trading import Client\n\n# Change server address if needed\nSERVICE_URL = \"grpc://electricity-trading.api.frequenz.com:443?ssl=true\"\nwith open('/path/to/api_key.txt', 'r', encoding='utf-8') as f:\n    API_KEY = f.read().strip()\n\nasync def stream_trades():\n    client = Client(\n        server_url=SERVICE_URL,\n        auth_key=API_KEY\n    )\n    stream_public_trades = await client.stream_public_trades()\n    async for public_trade in stream_public_trades:\n        print(f\"Received public trade: {public_trade}\")\n\nasyncio.run(stream_trades())\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading-classes","title":"Classes","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Client","title":"frequenz.client.electricity_trading.Client","text":"<p>               Bases: <code>BaseApiClient[ElectricityTradingServiceStub]</code></p> <p>Electricity trading client.</p> Source code in <code>frequenz/client/electricity_trading/_client.py</code> <pre><code>class Client(BaseApiClient[ElectricityTradingServiceStub]):\n    \"\"\"Electricity trading client.\"\"\"\n\n    _instances: dict[tuple[str, str | None], \"Client\"] = {}\n\n    def __new__(\n        cls, server_url: str, connect: bool = True, auth_key: str | None = None\n    ) -&gt; \"Client\":\n        \"\"\"\n        Create a new instance of the client or return an existing one if it already exists.\n\n        Args:\n            server_url: The URL of the Electricity Trading service.\n            connect: Whether to connect to the server immediately.\n            auth_key: The API key for the authorization.\n\n        Returns:\n            The client instance.\n        \"\"\"\n        key = (server_url, auth_key)\n\n        # Check if an instance already exists for this key\n        if key not in cls._instances:\n            # If not, create a new instance and store it in the cache\n            instance = super(Client, cls).__new__(cls)\n            cls._instances[key] = instance\n\n        return cls._instances[key]\n\n    def __init__(\n        self, server_url: str, connect: bool = True, auth_key: str | None = None\n    ) -&gt; None:\n        \"\"\"Initialize the client.\n\n        Args:\n            server_url: The URL of the Electricity Trading service.\n            connect: Whether to connect to the server immediately.\n            auth_key: The API key for the authorization.\n        \"\"\"\n        if not hasattr(\n            self, \"_initialized\"\n        ):  # Prevent re-initialization of existing instances\n            super().__init__(\n                server_url,\n                connect=connect,\n                create_stub=ElectricityTradingServiceStub,\n            )\n            self._initialized = True\n\n        self._gridpool_orders_streams: dict[\n            tuple[int, GridpoolOrderFilter],\n            GrpcStreamBroadcaster[\n                electricity_trading_pb2.ReceiveGridpoolOrdersStreamResponse, OrderDetail\n            ],\n        ] = {}\n\n        self._gridpool_trades_streams: dict[\n            tuple[int, GridpoolTradeFilter],\n            GrpcStreamBroadcaster[\n                electricity_trading_pb2.ReceiveGridpoolTradesStreamResponse, Trade\n            ],\n        ] = {}\n\n        self._public_trades_streams: dict[\n            PublicTradeFilter,\n            GrpcStreamBroadcaster[\n                electricity_trading_pb2.ReceivePublicTradesStreamResponse, PublicTrade\n            ],\n        ] = {}\n\n        self._metadata = ((\"key\", auth_key),) if auth_key else ()\n\n    @property\n    def stub(self) -&gt; electricity_trading_pb2_grpc.ElectricityTradingServiceAsyncStub:\n        \"\"\"\n        Get the gRPC stub for the Electricity Trading service.\n\n        Returns:\n            The gRPC stub.\n\n        Raises:\n            ClientNotConnected: If the client is not connected to the server.\n        \"\"\"\n        if self._stub is None:\n            raise ClientNotConnected(server_url=self.server_url, operation=\"stub\")\n        # This type: ignore is needed because we need to cast the sync stub to\n        # the async stub, but we can't use cast because the async stub doesn't\n        # actually exists to the eyes of the interpreter, it only exists for the\n        # type-checker, so it can only be used for type hints.\n        return self._stub  # type: ignore\n\n    async def stream_gridpool_orders(\n        # pylint: disable=too-many-arguments, too-many-positional-arguments\n        self,\n        gridpool_id: int,\n        order_states: list[OrderState] | None = None,\n        market_side: MarketSide | None = None,\n        delivery_area: DeliveryArea | None = None,\n        delivery_period: DeliveryPeriod | None = None,\n        tag: str | None = None,\n    ) -&gt; Receiver[OrderDetail]:\n        \"\"\"\n        Stream gridpool orders.\n\n        Args:\n            gridpool_id: ID of the gridpool to stream orders for.\n            order_states: List of order states to filter for.\n            market_side: Market side to filter for.\n            delivery_area: Delivery area to filter for.\n            delivery_period: Delivery period to filter for.\n            tag: Tag to filter for.\n\n        Returns:\n            Async generator of orders.\n\n        Raises:\n            grpc.RpcError: If an error occurs while streaming the orders.\n        \"\"\"\n        self.validate_params(delivery_period=delivery_period)\n\n        gridpool_order_filter = GridpoolOrderFilter(\n            order_states=order_states,\n            side=market_side,\n            delivery_area=delivery_area,\n            delivery_period=delivery_period,\n            tag=tag,\n        )\n\n        stream_key = (gridpool_id, gridpool_order_filter)\n\n        if stream_key not in self._gridpool_orders_streams:\n            try:\n                self._gridpool_orders_streams[stream_key] = GrpcStreamBroadcaster(\n                    f\"electricity-trading-{stream_key}\",\n                    lambda: self.stub.ReceiveGridpoolOrdersStream(\n                        electricity_trading_pb2.ReceiveGridpoolOrdersStreamRequest(\n                            gridpool_id=gridpool_id,\n                            filter=gridpool_order_filter.to_pb(),\n                        ),\n                        metadata=self._metadata,\n                    ),\n                    lambda response: OrderDetail.from_pb(response.order_detail),\n                )\n            except grpc.RpcError as e:\n                _logger.exception(\n                    \"Error occurred while streaming gridpool orders: %s\", e\n                )\n                raise\n        return self._gridpool_orders_streams[stream_key].new_receiver()\n\n    async def stream_gridpool_trades(\n        # pylint: disable=too-many-arguments, too-many-positional-arguments\n        self,\n        gridpool_id: int,\n        trade_states: list[TradeState] | None = None,\n        trade_ids: list[int] | None = None,\n        market_side: MarketSide | None = None,\n        delivery_period: DeliveryPeriod | None = None,\n        delivery_area: DeliveryArea | None = None,\n    ) -&gt; Receiver[Trade]:\n        \"\"\"\n        Stream gridpool trades.\n\n        Args:\n            gridpool_id: The ID of the gridpool to stream trades for.\n            trade_states: List of trade states to filter for.\n            trade_ids: List of trade IDs to filter for.\n            market_side: The market side to filter for.\n            delivery_period: The delivery period to filter for.\n            delivery_area: The delivery area to filter for.\n\n        Returns:\n            The gridpool trades streamer.\n\n        Raises:\n            grpc.RpcError: If an error occurs while streaming gridpool trades.\n        \"\"\"\n        self.validate_params(delivery_period=delivery_period)\n\n        gridpool_trade_filter = GridpoolTradeFilter(\n            trade_states=trade_states,\n            trade_ids=trade_ids,\n            side=market_side,\n            delivery_period=delivery_period,\n            delivery_area=delivery_area,\n        )\n\n        stream_key = (gridpool_id, gridpool_trade_filter)\n\n        if stream_key not in self._gridpool_trades_streams:\n            try:\n                self._gridpool_trades_streams[stream_key] = GrpcStreamBroadcaster(\n                    f\"electricity-trading-{stream_key}\",\n                    lambda: self.stub.ReceiveGridpoolTradesStream(\n                        electricity_trading_pb2.ReceiveGridpoolTradesStreamRequest(\n                            gridpool_id=gridpool_id,\n                            filter=gridpool_trade_filter.to_pb(),\n                        ),\n                        metadata=self._metadata,\n                    ),\n                    lambda response: Trade.from_pb(response.trade),\n                )\n            except grpc.RpcError as e:\n                _logger.exception(\n                    \"Error occurred while streaming gridpool trades: %s\", e\n                )\n                raise\n        return self._gridpool_trades_streams[stream_key].new_receiver()\n\n    async def stream_public_trades(\n        self,\n        states: list[TradeState] | None = None,\n        delivery_period: DeliveryPeriod | None = None,\n        buy_delivery_area: DeliveryArea | None = None,\n        sell_delivery_area: DeliveryArea | None = None,\n    ) -&gt; Receiver[PublicTrade]:\n        \"\"\"\n        Stream public trades.\n\n        Args:\n            states: List of order states to filter for.\n            delivery_period: Delivery period to filter for.\n            buy_delivery_area: Buy delivery area to filter for.\n            sell_delivery_area: Sell delivery area to filter for.\n\n        Returns:\n            Async generator of orders.\n\n        Raises:\n            grpc.RpcError: If an error occurs while streaming public trades.\n        \"\"\"\n        self.validate_params(delivery_period=delivery_period)\n\n        public_trade_filter = PublicTradeFilter(\n            states=states,\n            delivery_period=delivery_period,\n            buy_delivery_area=buy_delivery_area,\n            sell_delivery_area=sell_delivery_area,\n        )\n\n        if public_trade_filter not in self._public_trades_streams:\n            try:\n                self._public_trades_streams[public_trade_filter] = (\n                    GrpcStreamBroadcaster(\n                        f\"electricity-trading-{public_trade_filter}\",\n                        lambda: self.stub.ReceivePublicTradesStream(\n                            electricity_trading_pb2.ReceivePublicTradesStreamRequest(\n                                filter=public_trade_filter.to_pb(),\n                            ),\n                            metadata=self._metadata,\n                        ),\n                        lambda response: PublicTrade.from_pb(response.public_trade),\n                    )\n                )\n            except grpc.RpcError as e:\n                _logger.exception(\"Error occurred while streaming public trades: %s\", e)\n                raise\n        return self._public_trades_streams[public_trade_filter].new_receiver()\n\n    def validate_params(\n        # pylint: disable=too-many-arguments, too-many-positional-arguments, too-many-branches\n        self,\n        price: Price | None | _Sentinel = NO_VALUE,\n        quantity: Power | None | _Sentinel = NO_VALUE,\n        stop_price: Price | None | _Sentinel = NO_VALUE,\n        peak_price_delta: Price | None | _Sentinel = NO_VALUE,\n        display_quantity: Power | None | _Sentinel = NO_VALUE,\n        delivery_period: DeliveryPeriod | None = None,\n        valid_until: datetime | None | _Sentinel = NO_VALUE,\n        execution_option: OrderExecutionOption | None | _Sentinel = NO_VALUE,\n        order_type: OrderType | None = None,\n    ) -&gt; None:\n        \"\"\"\n        Validate the parameters of an order.\n\n        This method ensures the following:\n        - Price and quantity values have the correct number of decimal places and are positive.\n        - The delivery_start and valid_until values are in the future.\n\n        Args:\n            price: The price of the order.\n            quantity: The quantity of the order.\n            stop_price: The stop price of the order.\n            peak_price_delta: The peak price delta of the order.\n            display_quantity: The display quantity of the order.\n            delivery_period: The delivery period of the order.\n            valid_until: The valid until of the order.\n            execution_option: The execution option of the order.\n            order_type: The order type.\n\n        Raises:\n            ValueError: If the parameters are invalid.\n            NotImplementedError: If the order type is not supported.\n        \"\"\"\n        if not isinstance(price, _Sentinel) and price is not None:\n            if price.amount &lt; MIN_PRICE or price.amount &gt; MAX_PRICE:\n                raise ValueError(f\"Price must be between {MIN_PRICE} and {MAX_PRICE}.\")\n            validate_decimal_places(price.amount, PRECISION_DECIMAL_PRICE, \"price\")\n        if not isinstance(quantity, _Sentinel) and quantity is not None:\n            if quantity.mw &lt;= 0:\n                raise ValueError(\"Quantity must be strictly positive\")\n            if quantity.mw &lt; MIN_QUANTITY_MW:\n                raise ValueError(f\"Quantity must be at least {MIN_QUANTITY_MW} MW.\")\n            validate_decimal_places(quantity.mw, PRECISION_DECIMAL_QUANTITY, \"quantity\")\n        if not isinstance(stop_price, _Sentinel) and stop_price is not None:\n            raise NotImplementedError(\n                \"STOP_LIMIT orders are not supported yet, so stop_price cannot be set.\"\n            )\n        if not isinstance(peak_price_delta, _Sentinel) and peak_price_delta is not None:\n            raise NotImplementedError(\n                \"ICEBERG orders are not supported yet, so peak_price_delta cannot be set.\"\n            )\n        if not isinstance(display_quantity, _Sentinel) and display_quantity is not None:\n            raise NotImplementedError(\n                \"ICEBERG orders are not supported yet, so display_quantity cannot be set.\"\n            )\n        if delivery_period is not None:\n            if delivery_period.start &lt; datetime.now(timezone.utc):\n                raise ValueError(\"delivery_period must be in the future\")\n        if not isinstance(valid_until, _Sentinel) and valid_until is not None:\n            if (\n                not isinstance(execution_option, _Sentinel)\n                and execution_option is not None\n            ):\n                if execution_option in [\n                    OrderExecutionOption.AON,\n                    OrderExecutionOption.FOK,\n                    OrderExecutionOption.IOC,\n                ]:\n                    raise ValueError(\n                        \"valid_until must be None when execution_option is set to AON, FOK, or IOC\"\n                    )\n\n            if valid_until &lt; datetime.now(timezone.utc):\n                raise ValueError(\"valid_until must be in the future\")\n        if order_type is not None:\n            if order_type != OrderType.LIMIT:\n                raise NotImplementedError(\"Currently only limit orders are supported.\")\n\n    async def create_gridpool_order(\n        # pylint: disable=too-many-arguments, too-many-positional-arguments, too-many-locals\n        self,\n        gridpool_id: int,\n        delivery_area: DeliveryArea,\n        delivery_period: DeliveryPeriod,\n        order_type: OrderType,\n        side: MarketSide,\n        price: Price,\n        quantity: Power,\n        stop_price: Price | None = None,\n        peak_price_delta: Price | None = None,\n        display_quantity: Power | None = None,\n        execution_option: OrderExecutionOption | None = None,\n        valid_until: datetime | None = None,\n        payload: dict[str, struct_pb2.Value] | None = None,\n        tag: str | None = None,\n        timeout: timedelta | None = None,\n    ) -&gt; OrderDetail:\n        \"\"\"\n        Create a gridpool order.\n\n        Args:\n            gridpool_id: ID of the gridpool to create the order for.\n            delivery_area: Delivery area of the order.\n            delivery_period: Delivery period of the order.\n            order_type: Type of the order.\n            side: Side of the order.\n            price: Price of the order.\n            quantity: Quantity of the order.\n            stop_price: Stop price of the order.\n            peak_price_delta: Peak price delta of the order.\n            display_quantity: Display quantity of the order.\n            execution_option: Execution option of the order.\n            valid_until: Valid until of the order.\n            payload: Payload of the order.\n            tag: Tag of the order.\n            timeout: Timeout duration, defaults to None.\n\n        Returns:\n            The created order.\n\n        Raises:\n            grpc.RpcError: An error occurred while creating the order.\n        \"\"\"\n        self.validate_params(\n            price=price,\n            quantity=quantity,\n            stop_price=stop_price,\n            peak_price_delta=peak_price_delta,\n            display_quantity=display_quantity,\n            delivery_period=delivery_period,\n            valid_until=valid_until,\n            execution_option=execution_option,\n            order_type=order_type,\n        )\n        order = Order(\n            delivery_area=delivery_area,\n            delivery_period=delivery_period,\n            type=order_type,\n            side=side,\n            price=price,\n            quantity=quantity,\n            stop_price=stop_price,\n            peak_price_delta=peak_price_delta,\n            display_quantity=display_quantity,\n            execution_option=execution_option,\n            valid_until=valid_until,\n            payload=payload,\n            tag=tag,\n        )\n\n        try:\n            response = await cast(\n                Awaitable[electricity_trading_pb2.CreateGridpoolOrderResponse],\n                grpc_call_with_timeout(\n                    self.stub.CreateGridpoolOrder,\n                    electricity_trading_pb2.CreateGridpoolOrderRequest(\n                        gridpool_id=gridpool_id, order=order.to_pb()\n                    ),\n                    metadata=self._metadata,\n                    timeout=timeout,\n                ),\n            )\n        except grpc.RpcError as e:\n            _logger.exception(\"Error occurred while creating gridpool order: %s\", e)\n            raise\n\n        return OrderDetail.from_pb(response.order_detail)\n\n    async def update_gridpool_order(\n        # pylint: disable=too-many-arguments, too-many-positional-arguments, too-many-locals\n        self,\n        gridpool_id: int,\n        order_id: int,\n        price: Price | None | _Sentinel = NO_VALUE,\n        quantity: Power | None | _Sentinel = NO_VALUE,\n        stop_price: Price | None | _Sentinel = NO_VALUE,\n        peak_price_delta: Price | None | _Sentinel = NO_VALUE,\n        display_quantity: Power | None | _Sentinel = NO_VALUE,\n        execution_option: OrderExecutionOption | None | _Sentinel = NO_VALUE,\n        valid_until: datetime | None | _Sentinel = NO_VALUE,\n        payload: dict[str, struct_pb2.Value] | None | _Sentinel = NO_VALUE,\n        tag: str | None | _Sentinel = NO_VALUE,\n        timeout: timedelta | None = None,\n    ) -&gt; OrderDetail:\n        \"\"\"\n        Update an existing order for a given Gridpool.\n\n        Args:\n            gridpool_id: ID of the Gridpool the order belongs to.\n            order_id: Order ID.\n            price: The updated limit price at which the contract is to be traded.\n                This is the maximum price for a BUY order or the minimum price for a SELL order.\n            quantity: The updated quantity of the contract being traded, specified in MW.\n            stop_price: Applicable for STOP_LIMIT orders. This is the updated stop price that\n                triggers the limit order.\n            peak_price_delta: Applicable for ICEBERG orders. This is the updated price difference\n                between the peak price and the limit price.\n            display_quantity: Applicable for ICEBERG orders. This is the updated quantity of the\n                order to be displayed in the order book.\n            execution_option: Updated execution options such as All or None, Fill or Kill, etc.\n            valid_until: This is an updated timestamp defining the time after which the order\n                should be cancelled if not filled. The timestamp is in UTC.\n            payload: Updated user-defined payload individual to a specific order. This can be any\n                data that the user wants to associate with the order.\n            tag: Updated user-defined tag to group related orders.\n            timeout: Timeout duration, defaults to None.\n\n        Returns:\n            The updated order.\n\n        Raises:\n            ValueError: If no fields to update are provided.\n            grpc.RpcError: An error occurred while updating the order.\n        \"\"\"\n        self.validate_params(\n            price=price,\n            quantity=quantity,\n            stop_price=stop_price,\n            peak_price_delta=peak_price_delta,\n            display_quantity=display_quantity,\n            valid_until=valid_until,\n            execution_option=execution_option,\n        )\n\n        params = {\n            \"price\": price,\n            \"quantity\": quantity,\n            \"stop_price\": stop_price,\n            \"peak_price_delta\": peak_price_delta,\n            \"display_quantity\": display_quantity,\n            \"execution_option\": execution_option,\n            \"valid_until\": valid_until,\n            \"payload\": payload,\n            \"tag\": tag,\n        }\n\n        if all(value is NO_VALUE for value in params.values()):\n            raise ValueError(\"At least one field to update must be provided.\")\n\n        paths = [param for param, value in params.items() if value is not NO_VALUE]\n\n        # Field mask specifying which fields should be updated\n        # This is used so that we can update parameters with None values\n        update_mask = field_mask_pb2.FieldMask(paths=paths)\n\n        update_order_fields = UpdateOrder(\n            price=None if price is NO_VALUE else price,  # type: ignore\n            quantity=None if quantity is NO_VALUE else quantity,  # type: ignore\n            stop_price=None if stop_price is NO_VALUE else stop_price,  # type: ignore\n            peak_price_delta=(\n                None if peak_price_delta is NO_VALUE else peak_price_delta  # type: ignore\n            ),\n            display_quantity=(\n                None if display_quantity is NO_VALUE else display_quantity  # type: ignore\n            ),\n            execution_option=(\n                None if execution_option is NO_VALUE else execution_option  # type: ignore\n            ),\n            valid_until=(\n                None if valid_until is NO_VALUE else valid_until  # type: ignore\n            ),\n            payload=None if payload is NO_VALUE else payload,  # type: ignore\n            tag=None if tag is NO_VALUE else tag,  # type: ignore\n        )\n\n        try:\n            response = await cast(\n                Awaitable[electricity_trading_pb2.UpdateGridpoolOrderResponse],\n                grpc_call_with_timeout(\n                    self.stub.UpdateGridpoolOrder,\n                    electricity_trading_pb2.UpdateGridpoolOrderRequest(\n                        gridpool_id=gridpool_id,\n                        order_id=order_id,\n                        update_order_fields=update_order_fields.to_pb(),\n                        update_mask=update_mask,\n                    ),\n                    metadata=self._metadata,\n                    timeout=timeout,\n                ),\n            )\n            return OrderDetail.from_pb(response.order_detail)\n\n        except grpc.RpcError as e:\n            _logger.exception(\"Error occurred while updating gridpool order: %s\", e)\n            raise\n\n    async def cancel_gridpool_order(\n        self, gridpool_id: int, order_id: int, timeout: timedelta | None = None\n    ) -&gt; OrderDetail:\n        \"\"\"\n        Cancel a single order for a given Gridpool.\n\n        Args:\n            gridpool_id: The Gridpool to cancel the order for.\n            order_id: The order to cancel.\n            timeout: Timeout duration, defaults to None.\n\n        Returns:\n            The cancelled order.\n\n        Raises:\n            grpc.RpcError: If an error occurs while cancelling the gridpool order.\n        \"\"\"\n        try:\n            response = await cast(\n                Awaitable[electricity_trading_pb2.CancelGridpoolOrderResponse],\n                grpc_call_with_timeout(\n                    self.stub.CancelGridpoolOrder,\n                    electricity_trading_pb2.CancelGridpoolOrderRequest(\n                        gridpool_id=gridpool_id, order_id=order_id\n                    ),\n                    metadata=self._metadata,\n                    timeout=timeout,\n                ),\n            )\n            return OrderDetail.from_pb(response.order_detail)\n        except grpc.RpcError as e:\n            _logger.exception(\"Error occurred while cancelling gridpool order: %s\", e)\n            raise\n\n    async def cancel_all_gridpool_orders(\n        self, gridpool_id: int, timeout: timedelta | None = None\n    ) -&gt; int:\n        \"\"\"\n        Cancel all orders for a specific Gridpool.\n\n        Args:\n            gridpool_id: The Gridpool to cancel the orders for.\n            timeout: Timeout duration, defaults to None.\n\n        Returns:\n            The ID of the Gridpool for which the orders were cancelled.\n\n        Raises:\n            grpc.RpcError: If an error occurs while cancelling all gridpool orders.\n        \"\"\"\n        try:\n            response = await cast(\n                Awaitable[electricity_trading_pb2.CancelAllGridpoolOrdersResponse],\n                grpc_call_with_timeout(\n                    self.stub.CancelAllGridpoolOrders,\n                    electricity_trading_pb2.CancelAllGridpoolOrdersRequest(\n                        gridpool_id=gridpool_id\n                    ),\n                    metadata=self._metadata,\n                    timeout=timeout,\n                ),\n            )\n\n            return response.gridpool_id\n        except grpc.RpcError as e:\n            _logger.exception(\n                \"Error occurred while cancelling all gridpool orders: %s\", e\n            )\n            raise\n\n    async def get_gridpool_order(\n        self, gridpool_id: int, order_id: int, timeout: timedelta | None = None\n    ) -&gt; OrderDetail:\n        \"\"\"\n        Get a single order from a given gridpool.\n\n        Args:\n            gridpool_id: The Gridpool to retrieve the order for.\n            order_id: The order to retrieve.\n            timeout: Timeout duration, defaults to None.\n\n        Returns:\n            The order.\n\n        Raises:\n            grpc.RpcError: If an error occurs while getting the order.\n        \"\"\"\n        try:\n            response = await cast(\n                Awaitable[electricity_trading_pb2.GetGridpoolOrderResponse],\n                grpc_call_with_timeout(\n                    self.stub.GetGridpoolOrder,\n                    electricity_trading_pb2.GetGridpoolOrderRequest(\n                        gridpool_id=gridpool_id, order_id=order_id\n                    ),\n                    metadata=self._metadata,\n                    timeout=timeout,\n                ),\n            )\n\n            return OrderDetail.from_pb(response.order_detail)\n        except grpc.RpcError as e:\n            _logger.exception(\"Error occurred while getting gridpool order: %s\", e)\n            raise\n\n    async def list_gridpool_orders(\n        # pylint: disable=too-many-arguments, too-many-positional-arguments, too-many-locals\n        self,\n        gridpool_id: int,\n        order_states: list[OrderState] | None = None,\n        side: MarketSide | None = None,\n        delivery_period: DeliveryPeriod | None = None,\n        delivery_area: DeliveryArea | None = None,\n        tag: str | None = None,\n        page_size: int | None = None,\n        timeout: timedelta | None = None,\n    ) -&gt; AsyncIterator[OrderDetail]:\n        \"\"\"\n        List orders for a specific Gridpool with optional filters.\n\n        Args:\n            gridpool_id: The Gridpool to retrieve the orders for.\n            order_states: List of order states to filter by.\n            side: The side of the market to filter by.\n            delivery_period: The delivery period to filter by.\n            delivery_area: The delivery area to filter by.\n            tag: The tag to filter by.\n            page_size: The number of orders to return per page.\n            timeout: Timeout duration, defaults to None.\n\n        Yields:\n            The list of orders for the given gridpool.\n\n        Raises:\n            grpc.RpcError: If an error occurs while listing the orders.\n        \"\"\"\n        gridpool_order_filter = GridpoolOrderFilter(\n            order_states=order_states,\n            side=side,\n            delivery_period=delivery_period,\n            delivery_area=delivery_area,\n            tag=tag,\n        )\n\n        request = electricity_trading_pb2.ListGridpoolOrdersRequest(\n            gridpool_id=gridpool_id,\n            filter=gridpool_order_filter.to_pb(),\n            pagination_params=(\n                Params(page_size=page_size).to_proto() if page_size else None\n            ),\n        )\n        while True:\n            try:\n                response = await cast(\n                    Awaitable[electricity_trading_pb2.ListGridpoolOrdersResponse],\n                    grpc_call_with_timeout(\n                        self.stub.ListGridpoolOrders,\n                        request,\n                        metadata=self._metadata,\n                        timeout=timeout,\n                    ),\n                )\n\n                for order_detail in response.order_details:\n                    yield OrderDetail.from_pb(order_detail)\n\n                if response.pagination_info.next_page_token:\n                    request.pagination_params.CopyFrom(\n                        PaginationParams(\n                            page_token=response.pagination_info.next_page_token\n                        )\n                    )\n                else:\n                    break\n\n            except grpc.RpcError as e:\n                _logger.exception(\"Error occurred while listing gridpool orders: %s\", e)\n                raise\n\n    async def list_gridpool_trades(\n        # pylint: disable=too-many-arguments, too-many-positional-arguments\n        self,\n        gridpool_id: int,\n        trade_states: list[TradeState] | None = None,\n        trade_ids: list[int] | None = None,\n        market_side: MarketSide | None = None,\n        delivery_period: DeliveryPeriod | None = None,\n        delivery_area: DeliveryArea | None = None,\n        page_size: int | None = None,\n        timeout: timedelta | None = None,\n    ) -&gt; AsyncIterator[Trade]:\n        \"\"\"\n        List trades for a specific Gridpool with optional filters.\n\n        Args:\n            gridpool_id: The Gridpool to retrieve the trades for.\n            trade_states: List of trade states to filter by.\n            trade_ids: List of trade IDs to filter by.\n            market_side: The side of the market to filter by.\n            delivery_period: The delivery period to filter by.\n            delivery_area: The delivery area to filter by.\n            page_size: The number of trades to return per page.\n            timeout: Timeout duration, defaults to None.\n\n        Yields:\n            The list of trades for the given gridpool.\n\n        Raises:\n            grpc.RpcError: If an error occurs while listing gridpool trades.\n        \"\"\"\n        gridpool_trade_filter = GridpoolTradeFilter(\n            trade_states=trade_states,\n            trade_ids=trade_ids,\n            side=market_side,\n            delivery_period=delivery_period,\n            delivery_area=delivery_area,\n        )\n\n        request = electricity_trading_pb2.ListGridpoolTradesRequest(\n            gridpool_id=gridpool_id,\n            filter=gridpool_trade_filter.to_pb(),\n            pagination_params=(\n                Params(page_size=page_size).to_proto() if page_size else None\n            ),\n        )\n\n        while True:\n            try:\n                response = await cast(\n                    Awaitable[electricity_trading_pb2.ListGridpoolTradesResponse],\n                    grpc_call_with_timeout(\n                        self.stub.ListGridpoolTrades,\n                        request,\n                        metadata=self._metadata,\n                        timeout=timeout,\n                    ),\n                )\n\n                for trade in response.trades:\n                    yield Trade.from_pb(trade)\n\n                if response.pagination_info.next_page_token:\n                    request.pagination_params.CopyFrom(\n                        PaginationParams(\n                            page_token=response.pagination_info.next_page_token\n                        )\n                    )\n                else:\n                    break\n\n            except grpc.RpcError as e:\n                _logger.exception(\"Error occurred while listing gridpool trades: %s\", e)\n                raise\n\n    async def list_public_trades(\n        # pylint: disable=too-many-arguments, too-many-positional-arguments\n        self,\n        states: list[TradeState] | None = None,\n        delivery_period: DeliveryPeriod | None = None,\n        buy_delivery_area: DeliveryArea | None = None,\n        sell_delivery_area: DeliveryArea | None = None,\n        page_size: int | None = None,\n        timeout: timedelta | None = None,\n    ) -&gt; AsyncIterator[PublicTrade]:\n        \"\"\"\n        List all executed public orders with optional filters and pagination.\n\n        Args:\n            states: List of order states to filter by.\n            delivery_period: The delivery period to filter by.\n            buy_delivery_area: The buy delivery area to filter by.\n            sell_delivery_area: The sell delivery area to filter by.\n            page_size: The number of public trades to return per page.\n            timeout: Timeout duration, defaults to None.\n\n        Yields:\n            The list of public trades for each page.\n\n        Raises:\n            grpc.RpcError: If an error occurs while listing public trades.\n        \"\"\"\n        public_trade_filter = PublicTradeFilter(\n            states=states,\n            delivery_period=delivery_period,\n            buy_delivery_area=buy_delivery_area,\n            sell_delivery_area=sell_delivery_area,\n        )\n\n        request = electricity_trading_pb2.ListPublicTradesRequest(\n            filter=public_trade_filter.to_pb(),\n            pagination_params=(\n                Params(page_size=page_size).to_proto() if page_size else None\n            ),\n        )\n\n        while True:\n            try:\n                response = await cast(\n                    Awaitable[electricity_trading_pb2.ListPublicTradesResponse],\n                    grpc_call_with_timeout(\n                        self.stub.ListPublicTrades,\n                        request,\n                        metadata=self._metadata,\n                        timeout=timeout,\n                    ),\n                )\n\n                for public_trade in response.public_trades:\n                    yield PublicTrade.from_pb(public_trade)\n\n                if response.pagination_info.next_page_token:\n                    request.pagination_params.CopyFrom(\n                        PaginationParams(\n                            page_token=response.pagination_info.next_page_token\n                        )\n                    )\n                else:\n                    break\n\n            except grpc.RpcError as e:\n                _logger.exception(\"Error occurred while listing public trades: %s\", e)\n                raise\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Client-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Client.channel","title":"channel  <code>property</code>","text":"<pre><code>channel: Channel\n</code></pre> <p>The underlying gRPC channel used to communicate with the server.</p> Warning <p>This channel is provided as a last resort for advanced users. It is not recommended to use this property directly unless you know what you are doing and you don't care about being tied to a specific gRPC library.</p> RAISES DESCRIPTION <code>ClientNotConnected</code> <p>If the client is not connected to the server.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Client.channel_defaults","title":"channel_defaults  <code>property</code>","text":"<pre><code>channel_defaults: ChannelOptions\n</code></pre> <p>The default options for the gRPC channel.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Client.is_connected","title":"is_connected  <code>property</code>","text":"<pre><code>is_connected: bool\n</code></pre> <p>Whether the client is connected to the server.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Client.server_url","title":"server_url  <code>property</code>","text":"<pre><code>server_url: str\n</code></pre> <p>The URL of the server.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Client.stub","title":"stub  <code>property</code>","text":"<pre><code>stub: ElectricityTradingServiceAsyncStub\n</code></pre> <p>Get the gRPC stub for the Electricity Trading service.</p> RETURNS DESCRIPTION <code>ElectricityTradingServiceAsyncStub</code> <p>The gRPC stub.</p> RAISES DESCRIPTION <code>ClientNotConnected</code> <p>If the client is not connected to the server.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Client-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Client.__aenter__","title":"__aenter__  <code>async</code>","text":"<pre><code>__aenter__() -&gt; Self\n</code></pre> <p>Enter a context manager.</p> Source code in <code>frequenz/client/base/client.py</code> <pre><code>async def __aenter__(self) -&gt; Self:\n    \"\"\"Enter a context manager.\"\"\"\n    self.connect()\n    return self\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Client.__aexit__","title":"__aexit__  <code>async</code>","text":"<pre><code>__aexit__(\n    _exc_type: type[BaseException] | None,\n    _exc_val: BaseException | None,\n    _exc_tb: Any | None,\n) -&gt; bool | None\n</code></pre> <p>Exit a context manager.</p> Source code in <code>frequenz/client/base/client.py</code> <pre><code>async def __aexit__(\n    self,\n    _exc_type: type[BaseException] | None,\n    _exc_val: BaseException | None,\n    _exc_tb: Any | None,\n) -&gt; bool | None:\n    \"\"\"Exit a context manager.\"\"\"\n    if self._channel is None:\n        return None\n    result = await self._channel.__aexit__(_exc_type, _exc_val, _exc_tb)\n    self._channel = None\n    self._stub = None\n    return result\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Client.__init__","title":"__init__","text":"<pre><code>__init__(\n    server_url: str,\n    connect: bool = True,\n    auth_key: str | None = None,\n) -&gt; None\n</code></pre> <p>Initialize the client.</p> PARAMETER DESCRIPTION <code>server_url</code> <p>The URL of the Electricity Trading service.</p> <p> TYPE: <code>str</code> </p> <code>connect</code> <p>Whether to connect to the server immediately.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>auth_key</code> <p>The API key for the authorization.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> Source code in <code>frequenz/client/electricity_trading/_client.py</code> <pre><code>def __init__(\n    self, server_url: str, connect: bool = True, auth_key: str | None = None\n) -&gt; None:\n    \"\"\"Initialize the client.\n\n    Args:\n        server_url: The URL of the Electricity Trading service.\n        connect: Whether to connect to the server immediately.\n        auth_key: The API key for the authorization.\n    \"\"\"\n    if not hasattr(\n        self, \"_initialized\"\n    ):  # Prevent re-initialization of existing instances\n        super().__init__(\n            server_url,\n            connect=connect,\n            create_stub=ElectricityTradingServiceStub,\n        )\n        self._initialized = True\n\n    self._gridpool_orders_streams: dict[\n        tuple[int, GridpoolOrderFilter],\n        GrpcStreamBroadcaster[\n            electricity_trading_pb2.ReceiveGridpoolOrdersStreamResponse, OrderDetail\n        ],\n    ] = {}\n\n    self._gridpool_trades_streams: dict[\n        tuple[int, GridpoolTradeFilter],\n        GrpcStreamBroadcaster[\n            electricity_trading_pb2.ReceiveGridpoolTradesStreamResponse, Trade\n        ],\n    ] = {}\n\n    self._public_trades_streams: dict[\n        PublicTradeFilter,\n        GrpcStreamBroadcaster[\n            electricity_trading_pb2.ReceivePublicTradesStreamResponse, PublicTrade\n        ],\n    ] = {}\n\n    self._metadata = ((\"key\", auth_key),) if auth_key else ()\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Client.__new__","title":"__new__","text":"<pre><code>__new__(\n    server_url: str,\n    connect: bool = True,\n    auth_key: str | None = None,\n) -&gt; \"Client\"\n</code></pre> <p>Create a new instance of the client or return an existing one if it already exists.</p> PARAMETER DESCRIPTION <code>server_url</code> <p>The URL of the Electricity Trading service.</p> <p> TYPE: <code>str</code> </p> <code>connect</code> <p>Whether to connect to the server immediately.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>auth_key</code> <p>The API key for the authorization.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>'Client'</code> <p>The client instance.</p> Source code in <code>frequenz/client/electricity_trading/_client.py</code> <pre><code>def __new__(\n    cls, server_url: str, connect: bool = True, auth_key: str | None = None\n) -&gt; \"Client\":\n    \"\"\"\n    Create a new instance of the client or return an existing one if it already exists.\n\n    Args:\n        server_url: The URL of the Electricity Trading service.\n        connect: Whether to connect to the server immediately.\n        auth_key: The API key for the authorization.\n\n    Returns:\n        The client instance.\n    \"\"\"\n    key = (server_url, auth_key)\n\n    # Check if an instance already exists for this key\n    if key not in cls._instances:\n        # If not, create a new instance and store it in the cache\n        instance = super(Client, cls).__new__(cls)\n        cls._instances[key] = instance\n\n    return cls._instances[key]\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Client.cancel_all_gridpool_orders","title":"cancel_all_gridpool_orders  <code>async</code>","text":"<pre><code>cancel_all_gridpool_orders(\n    gridpool_id: int, timeout: timedelta | None = None\n) -&gt; int\n</code></pre> <p>Cancel all orders for a specific Gridpool.</p> PARAMETER DESCRIPTION <code>gridpool_id</code> <p>The Gridpool to cancel the orders for.</p> <p> TYPE: <code>int</code> </p> <code>timeout</code> <p>Timeout duration, defaults to None.</p> <p> TYPE: <code>timedelta | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>int</code> <p>The ID of the Gridpool for which the orders were cancelled.</p> RAISES DESCRIPTION <code>RpcError</code> <p>If an error occurs while cancelling all gridpool orders.</p> Source code in <code>frequenz/client/electricity_trading/_client.py</code> <pre><code>async def cancel_all_gridpool_orders(\n    self, gridpool_id: int, timeout: timedelta | None = None\n) -&gt; int:\n    \"\"\"\n    Cancel all orders for a specific Gridpool.\n\n    Args:\n        gridpool_id: The Gridpool to cancel the orders for.\n        timeout: Timeout duration, defaults to None.\n\n    Returns:\n        The ID of the Gridpool for which the orders were cancelled.\n\n    Raises:\n        grpc.RpcError: If an error occurs while cancelling all gridpool orders.\n    \"\"\"\n    try:\n        response = await cast(\n            Awaitable[electricity_trading_pb2.CancelAllGridpoolOrdersResponse],\n            grpc_call_with_timeout(\n                self.stub.CancelAllGridpoolOrders,\n                electricity_trading_pb2.CancelAllGridpoolOrdersRequest(\n                    gridpool_id=gridpool_id\n                ),\n                metadata=self._metadata,\n                timeout=timeout,\n            ),\n        )\n\n        return response.gridpool_id\n    except grpc.RpcError as e:\n        _logger.exception(\n            \"Error occurred while cancelling all gridpool orders: %s\", e\n        )\n        raise\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Client.cancel_gridpool_order","title":"cancel_gridpool_order  <code>async</code>","text":"<pre><code>cancel_gridpool_order(\n    gridpool_id: int,\n    order_id: int,\n    timeout: timedelta | None = None,\n) -&gt; OrderDetail\n</code></pre> <p>Cancel a single order for a given Gridpool.</p> PARAMETER DESCRIPTION <code>gridpool_id</code> <p>The Gridpool to cancel the order for.</p> <p> TYPE: <code>int</code> </p> <code>order_id</code> <p>The order to cancel.</p> <p> TYPE: <code>int</code> </p> <code>timeout</code> <p>Timeout duration, defaults to None.</p> <p> TYPE: <code>timedelta | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>OrderDetail</code> <p>The cancelled order.</p> RAISES DESCRIPTION <code>RpcError</code> <p>If an error occurs while cancelling the gridpool order.</p> Source code in <code>frequenz/client/electricity_trading/_client.py</code> <pre><code>async def cancel_gridpool_order(\n    self, gridpool_id: int, order_id: int, timeout: timedelta | None = None\n) -&gt; OrderDetail:\n    \"\"\"\n    Cancel a single order for a given Gridpool.\n\n    Args:\n        gridpool_id: The Gridpool to cancel the order for.\n        order_id: The order to cancel.\n        timeout: Timeout duration, defaults to None.\n\n    Returns:\n        The cancelled order.\n\n    Raises:\n        grpc.RpcError: If an error occurs while cancelling the gridpool order.\n    \"\"\"\n    try:\n        response = await cast(\n            Awaitable[electricity_trading_pb2.CancelGridpoolOrderResponse],\n            grpc_call_with_timeout(\n                self.stub.CancelGridpoolOrder,\n                electricity_trading_pb2.CancelGridpoolOrderRequest(\n                    gridpool_id=gridpool_id, order_id=order_id\n                ),\n                metadata=self._metadata,\n                timeout=timeout,\n            ),\n        )\n        return OrderDetail.from_pb(response.order_detail)\n    except grpc.RpcError as e:\n        _logger.exception(\"Error occurred while cancelling gridpool order: %s\", e)\n        raise\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Client.connect","title":"connect","text":"<pre><code>connect(server_url: str | None = None) -&gt; None\n</code></pre> <p>Connect to the server, possibly using a new URL.</p> <p>If the client is already connected and the URL is the same as the previous URL, this method does nothing. If you want to force a reconnection, you can call disconnect() first.</p> PARAMETER DESCRIPTION <code>server_url</code> <p>The URL of the server to connect to. If not provided, the previously used URL is used.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> Source code in <code>frequenz/client/base/client.py</code> <pre><code>def connect(self, server_url: str | None = None) -&gt; None:\n    \"\"\"Connect to the server, possibly using a new URL.\n\n    If the client is already connected and the URL is the same as the previous URL,\n    this method does nothing. If you want to force a reconnection, you can call\n    [disconnect()][frequenz.client.base.client.BaseApiClient.disconnect] first.\n\n    Args:\n        server_url: The URL of the server to connect to. If not provided, the\n            previously used URL is used.\n    \"\"\"\n    if server_url is not None and server_url != self._server_url:  # URL changed\n        self._server_url = server_url\n    elif self.is_connected:\n        return\n    self._channel = parse_grpc_uri(self._server_url, self._channel_defaults)\n    self._stub = self._create_stub(self._channel)\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Client.create_gridpool_order","title":"create_gridpool_order  <code>async</code>","text":"<pre><code>create_gridpool_order(\n    gridpool_id: int,\n    delivery_area: DeliveryArea,\n    delivery_period: DeliveryPeriod,\n    order_type: OrderType,\n    side: MarketSide,\n    price: Price,\n    quantity: Power,\n    stop_price: Price | None = None,\n    peak_price_delta: Price | None = None,\n    display_quantity: Power | None = None,\n    execution_option: OrderExecutionOption | None = None,\n    valid_until: datetime | None = None,\n    payload: dict[str, Value] | None = None,\n    tag: str | None = None,\n    timeout: timedelta | None = None,\n) -&gt; OrderDetail\n</code></pre> <p>Create a gridpool order.</p> PARAMETER DESCRIPTION <code>gridpool_id</code> <p>ID of the gridpool to create the order for.</p> <p> TYPE: <code>int</code> </p> <code>delivery_area</code> <p>Delivery area of the order.</p> <p> TYPE: <code>DeliveryArea</code> </p> <code>delivery_period</code> <p>Delivery period of the order.</p> <p> TYPE: <code>DeliveryPeriod</code> </p> <code>order_type</code> <p>Type of the order.</p> <p> TYPE: <code>OrderType</code> </p> <code>side</code> <p>Side of the order.</p> <p> TYPE: <code>MarketSide</code> </p> <code>price</code> <p>Price of the order.</p> <p> TYPE: <code>Price</code> </p> <code>quantity</code> <p>Quantity of the order.</p> <p> TYPE: <code>Power</code> </p> <code>stop_price</code> <p>Stop price of the order.</p> <p> TYPE: <code>Price | None</code> DEFAULT: <code>None</code> </p> <code>peak_price_delta</code> <p>Peak price delta of the order.</p> <p> TYPE: <code>Price | None</code> DEFAULT: <code>None</code> </p> <code>display_quantity</code> <p>Display quantity of the order.</p> <p> TYPE: <code>Power | None</code> DEFAULT: <code>None</code> </p> <code>execution_option</code> <p>Execution option of the order.</p> <p> TYPE: <code>OrderExecutionOption | None</code> DEFAULT: <code>None</code> </p> <code>valid_until</code> <p>Valid until of the order.</p> <p> TYPE: <code>datetime | None</code> DEFAULT: <code>None</code> </p> <code>payload</code> <p>Payload of the order.</p> <p> TYPE: <code>dict[str, Value] | None</code> DEFAULT: <code>None</code> </p> <code>tag</code> <p>Tag of the order.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>timeout</code> <p>Timeout duration, defaults to None.</p> <p> TYPE: <code>timedelta | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>OrderDetail</code> <p>The created order.</p> RAISES DESCRIPTION <code>RpcError</code> <p>An error occurred while creating the order.</p> Source code in <code>frequenz/client/electricity_trading/_client.py</code> <pre><code>async def create_gridpool_order(\n    # pylint: disable=too-many-arguments, too-many-positional-arguments, too-many-locals\n    self,\n    gridpool_id: int,\n    delivery_area: DeliveryArea,\n    delivery_period: DeliveryPeriod,\n    order_type: OrderType,\n    side: MarketSide,\n    price: Price,\n    quantity: Power,\n    stop_price: Price | None = None,\n    peak_price_delta: Price | None = None,\n    display_quantity: Power | None = None,\n    execution_option: OrderExecutionOption | None = None,\n    valid_until: datetime | None = None,\n    payload: dict[str, struct_pb2.Value] | None = None,\n    tag: str | None = None,\n    timeout: timedelta | None = None,\n) -&gt; OrderDetail:\n    \"\"\"\n    Create a gridpool order.\n\n    Args:\n        gridpool_id: ID of the gridpool to create the order for.\n        delivery_area: Delivery area of the order.\n        delivery_period: Delivery period of the order.\n        order_type: Type of the order.\n        side: Side of the order.\n        price: Price of the order.\n        quantity: Quantity of the order.\n        stop_price: Stop price of the order.\n        peak_price_delta: Peak price delta of the order.\n        display_quantity: Display quantity of the order.\n        execution_option: Execution option of the order.\n        valid_until: Valid until of the order.\n        payload: Payload of the order.\n        tag: Tag of the order.\n        timeout: Timeout duration, defaults to None.\n\n    Returns:\n        The created order.\n\n    Raises:\n        grpc.RpcError: An error occurred while creating the order.\n    \"\"\"\n    self.validate_params(\n        price=price,\n        quantity=quantity,\n        stop_price=stop_price,\n        peak_price_delta=peak_price_delta,\n        display_quantity=display_quantity,\n        delivery_period=delivery_period,\n        valid_until=valid_until,\n        execution_option=execution_option,\n        order_type=order_type,\n    )\n    order = Order(\n        delivery_area=delivery_area,\n        delivery_period=delivery_period,\n        type=order_type,\n        side=side,\n        price=price,\n        quantity=quantity,\n        stop_price=stop_price,\n        peak_price_delta=peak_price_delta,\n        display_quantity=display_quantity,\n        execution_option=execution_option,\n        valid_until=valid_until,\n        payload=payload,\n        tag=tag,\n    )\n\n    try:\n        response = await cast(\n            Awaitable[electricity_trading_pb2.CreateGridpoolOrderResponse],\n            grpc_call_with_timeout(\n                self.stub.CreateGridpoolOrder,\n                electricity_trading_pb2.CreateGridpoolOrderRequest(\n                    gridpool_id=gridpool_id, order=order.to_pb()\n                ),\n                metadata=self._metadata,\n                timeout=timeout,\n            ),\n        )\n    except grpc.RpcError as e:\n        _logger.exception(\"Error occurred while creating gridpool order: %s\", e)\n        raise\n\n    return OrderDetail.from_pb(response.order_detail)\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Client.disconnect","title":"disconnect  <code>async</code>","text":"<pre><code>disconnect() -&gt; None\n</code></pre> <p>Disconnect from the server.</p> <p>If the client is not connected, this method does nothing.</p> Source code in <code>frequenz/client/base/client.py</code> <pre><code>async def disconnect(self) -&gt; None:\n    \"\"\"Disconnect from the server.\n\n    If the client is not connected, this method does nothing.\n    \"\"\"\n    await self.__aexit__(None, None, None)\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Client.get_gridpool_order","title":"get_gridpool_order  <code>async</code>","text":"<pre><code>get_gridpool_order(\n    gridpool_id: int,\n    order_id: int,\n    timeout: timedelta | None = None,\n) -&gt; OrderDetail\n</code></pre> <p>Get a single order from a given gridpool.</p> PARAMETER DESCRIPTION <code>gridpool_id</code> <p>The Gridpool to retrieve the order for.</p> <p> TYPE: <code>int</code> </p> <code>order_id</code> <p>The order to retrieve.</p> <p> TYPE: <code>int</code> </p> <code>timeout</code> <p>Timeout duration, defaults to None.</p> <p> TYPE: <code>timedelta | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>OrderDetail</code> <p>The order.</p> RAISES DESCRIPTION <code>RpcError</code> <p>If an error occurs while getting the order.</p> Source code in <code>frequenz/client/electricity_trading/_client.py</code> <pre><code>async def get_gridpool_order(\n    self, gridpool_id: int, order_id: int, timeout: timedelta | None = None\n) -&gt; OrderDetail:\n    \"\"\"\n    Get a single order from a given gridpool.\n\n    Args:\n        gridpool_id: The Gridpool to retrieve the order for.\n        order_id: The order to retrieve.\n        timeout: Timeout duration, defaults to None.\n\n    Returns:\n        The order.\n\n    Raises:\n        grpc.RpcError: If an error occurs while getting the order.\n    \"\"\"\n    try:\n        response = await cast(\n            Awaitable[electricity_trading_pb2.GetGridpoolOrderResponse],\n            grpc_call_with_timeout(\n                self.stub.GetGridpoolOrder,\n                electricity_trading_pb2.GetGridpoolOrderRequest(\n                    gridpool_id=gridpool_id, order_id=order_id\n                ),\n                metadata=self._metadata,\n                timeout=timeout,\n            ),\n        )\n\n        return OrderDetail.from_pb(response.order_detail)\n    except grpc.RpcError as e:\n        _logger.exception(\"Error occurred while getting gridpool order: %s\", e)\n        raise\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Client.list_gridpool_orders","title":"list_gridpool_orders  <code>async</code>","text":"<pre><code>list_gridpool_orders(\n    gridpool_id: int,\n    order_states: list[OrderState] | None = None,\n    side: MarketSide | None = None,\n    delivery_period: DeliveryPeriod | None = None,\n    delivery_area: DeliveryArea | None = None,\n    tag: str | None = None,\n    page_size: int | None = None,\n    timeout: timedelta | None = None,\n) -&gt; AsyncIterator[OrderDetail]\n</code></pre> <p>List orders for a specific Gridpool with optional filters.</p> PARAMETER DESCRIPTION <code>gridpool_id</code> <p>The Gridpool to retrieve the orders for.</p> <p> TYPE: <code>int</code> </p> <code>order_states</code> <p>List of order states to filter by.</p> <p> TYPE: <code>list[OrderState] | None</code> DEFAULT: <code>None</code> </p> <code>side</code> <p>The side of the market to filter by.</p> <p> TYPE: <code>MarketSide | None</code> DEFAULT: <code>None</code> </p> <code>delivery_period</code> <p>The delivery period to filter by.</p> <p> TYPE: <code>DeliveryPeriod | None</code> DEFAULT: <code>None</code> </p> <code>delivery_area</code> <p>The delivery area to filter by.</p> <p> TYPE: <code>DeliveryArea | None</code> DEFAULT: <code>None</code> </p> <code>tag</code> <p>The tag to filter by.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>page_size</code> <p>The number of orders to return per page.</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> <code>timeout</code> <p>Timeout duration, defaults to None.</p> <p> TYPE: <code>timedelta | None</code> DEFAULT: <code>None</code> </p> YIELDS DESCRIPTION <code>AsyncIterator[OrderDetail]</code> <p>The list of orders for the given gridpool.</p> RAISES DESCRIPTION <code>RpcError</code> <p>If an error occurs while listing the orders.</p> Source code in <code>frequenz/client/electricity_trading/_client.py</code> <pre><code>async def list_gridpool_orders(\n    # pylint: disable=too-many-arguments, too-many-positional-arguments, too-many-locals\n    self,\n    gridpool_id: int,\n    order_states: list[OrderState] | None = None,\n    side: MarketSide | None = None,\n    delivery_period: DeliveryPeriod | None = None,\n    delivery_area: DeliveryArea | None = None,\n    tag: str | None = None,\n    page_size: int | None = None,\n    timeout: timedelta | None = None,\n) -&gt; AsyncIterator[OrderDetail]:\n    \"\"\"\n    List orders for a specific Gridpool with optional filters.\n\n    Args:\n        gridpool_id: The Gridpool to retrieve the orders for.\n        order_states: List of order states to filter by.\n        side: The side of the market to filter by.\n        delivery_period: The delivery period to filter by.\n        delivery_area: The delivery area to filter by.\n        tag: The tag to filter by.\n        page_size: The number of orders to return per page.\n        timeout: Timeout duration, defaults to None.\n\n    Yields:\n        The list of orders for the given gridpool.\n\n    Raises:\n        grpc.RpcError: If an error occurs while listing the orders.\n    \"\"\"\n    gridpool_order_filter = GridpoolOrderFilter(\n        order_states=order_states,\n        side=side,\n        delivery_period=delivery_period,\n        delivery_area=delivery_area,\n        tag=tag,\n    )\n\n    request = electricity_trading_pb2.ListGridpoolOrdersRequest(\n        gridpool_id=gridpool_id,\n        filter=gridpool_order_filter.to_pb(),\n        pagination_params=(\n            Params(page_size=page_size).to_proto() if page_size else None\n        ),\n    )\n    while True:\n        try:\n            response = await cast(\n                Awaitable[electricity_trading_pb2.ListGridpoolOrdersResponse],\n                grpc_call_with_timeout(\n                    self.stub.ListGridpoolOrders,\n                    request,\n                    metadata=self._metadata,\n                    timeout=timeout,\n                ),\n            )\n\n            for order_detail in response.order_details:\n                yield OrderDetail.from_pb(order_detail)\n\n            if response.pagination_info.next_page_token:\n                request.pagination_params.CopyFrom(\n                    PaginationParams(\n                        page_token=response.pagination_info.next_page_token\n                    )\n                )\n            else:\n                break\n\n        except grpc.RpcError as e:\n            _logger.exception(\"Error occurred while listing gridpool orders: %s\", e)\n            raise\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Client.list_gridpool_trades","title":"list_gridpool_trades  <code>async</code>","text":"<pre><code>list_gridpool_trades(\n    gridpool_id: int,\n    trade_states: list[TradeState] | None = None,\n    trade_ids: list[int] | None = None,\n    market_side: MarketSide | None = None,\n    delivery_period: DeliveryPeriod | None = None,\n    delivery_area: DeliveryArea | None = None,\n    page_size: int | None = None,\n    timeout: timedelta | None = None,\n) -&gt; AsyncIterator[Trade]\n</code></pre> <p>List trades for a specific Gridpool with optional filters.</p> PARAMETER DESCRIPTION <code>gridpool_id</code> <p>The Gridpool to retrieve the trades for.</p> <p> TYPE: <code>int</code> </p> <code>trade_states</code> <p>List of trade states to filter by.</p> <p> TYPE: <code>list[TradeState] | None</code> DEFAULT: <code>None</code> </p> <code>trade_ids</code> <p>List of trade IDs to filter by.</p> <p> TYPE: <code>list[int] | None</code> DEFAULT: <code>None</code> </p> <code>market_side</code> <p>The side of the market to filter by.</p> <p> TYPE: <code>MarketSide | None</code> DEFAULT: <code>None</code> </p> <code>delivery_period</code> <p>The delivery period to filter by.</p> <p> TYPE: <code>DeliveryPeriod | None</code> DEFAULT: <code>None</code> </p> <code>delivery_area</code> <p>The delivery area to filter by.</p> <p> TYPE: <code>DeliveryArea | None</code> DEFAULT: <code>None</code> </p> <code>page_size</code> <p>The number of trades to return per page.</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> <code>timeout</code> <p>Timeout duration, defaults to None.</p> <p> TYPE: <code>timedelta | None</code> DEFAULT: <code>None</code> </p> YIELDS DESCRIPTION <code>AsyncIterator[Trade]</code> <p>The list of trades for the given gridpool.</p> RAISES DESCRIPTION <code>RpcError</code> <p>If an error occurs while listing gridpool trades.</p> Source code in <code>frequenz/client/electricity_trading/_client.py</code> <pre><code>async def list_gridpool_trades(\n    # pylint: disable=too-many-arguments, too-many-positional-arguments\n    self,\n    gridpool_id: int,\n    trade_states: list[TradeState] | None = None,\n    trade_ids: list[int] | None = None,\n    market_side: MarketSide | None = None,\n    delivery_period: DeliveryPeriod | None = None,\n    delivery_area: DeliveryArea | None = None,\n    page_size: int | None = None,\n    timeout: timedelta | None = None,\n) -&gt; AsyncIterator[Trade]:\n    \"\"\"\n    List trades for a specific Gridpool with optional filters.\n\n    Args:\n        gridpool_id: The Gridpool to retrieve the trades for.\n        trade_states: List of trade states to filter by.\n        trade_ids: List of trade IDs to filter by.\n        market_side: The side of the market to filter by.\n        delivery_period: The delivery period to filter by.\n        delivery_area: The delivery area to filter by.\n        page_size: The number of trades to return per page.\n        timeout: Timeout duration, defaults to None.\n\n    Yields:\n        The list of trades for the given gridpool.\n\n    Raises:\n        grpc.RpcError: If an error occurs while listing gridpool trades.\n    \"\"\"\n    gridpool_trade_filter = GridpoolTradeFilter(\n        trade_states=trade_states,\n        trade_ids=trade_ids,\n        side=market_side,\n        delivery_period=delivery_period,\n        delivery_area=delivery_area,\n    )\n\n    request = electricity_trading_pb2.ListGridpoolTradesRequest(\n        gridpool_id=gridpool_id,\n        filter=gridpool_trade_filter.to_pb(),\n        pagination_params=(\n            Params(page_size=page_size).to_proto() if page_size else None\n        ),\n    )\n\n    while True:\n        try:\n            response = await cast(\n                Awaitable[electricity_trading_pb2.ListGridpoolTradesResponse],\n                grpc_call_with_timeout(\n                    self.stub.ListGridpoolTrades,\n                    request,\n                    metadata=self._metadata,\n                    timeout=timeout,\n                ),\n            )\n\n            for trade in response.trades:\n                yield Trade.from_pb(trade)\n\n            if response.pagination_info.next_page_token:\n                request.pagination_params.CopyFrom(\n                    PaginationParams(\n                        page_token=response.pagination_info.next_page_token\n                    )\n                )\n            else:\n                break\n\n        except grpc.RpcError as e:\n            _logger.exception(\"Error occurred while listing gridpool trades: %s\", e)\n            raise\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Client.list_public_trades","title":"list_public_trades  <code>async</code>","text":"<pre><code>list_public_trades(\n    states: list[TradeState] | None = None,\n    delivery_period: DeliveryPeriod | None = None,\n    buy_delivery_area: DeliveryArea | None = None,\n    sell_delivery_area: DeliveryArea | None = None,\n    page_size: int | None = None,\n    timeout: timedelta | None = None,\n) -&gt; AsyncIterator[PublicTrade]\n</code></pre> <p>List all executed public orders with optional filters and pagination.</p> PARAMETER DESCRIPTION <code>states</code> <p>List of order states to filter by.</p> <p> TYPE: <code>list[TradeState] | None</code> DEFAULT: <code>None</code> </p> <code>delivery_period</code> <p>The delivery period to filter by.</p> <p> TYPE: <code>DeliveryPeriod | None</code> DEFAULT: <code>None</code> </p> <code>buy_delivery_area</code> <p>The buy delivery area to filter by.</p> <p> TYPE: <code>DeliveryArea | None</code> DEFAULT: <code>None</code> </p> <code>sell_delivery_area</code> <p>The sell delivery area to filter by.</p> <p> TYPE: <code>DeliveryArea | None</code> DEFAULT: <code>None</code> </p> <code>page_size</code> <p>The number of public trades to return per page.</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> <code>timeout</code> <p>Timeout duration, defaults to None.</p> <p> TYPE: <code>timedelta | None</code> DEFAULT: <code>None</code> </p> YIELDS DESCRIPTION <code>AsyncIterator[PublicTrade]</code> <p>The list of public trades for each page.</p> RAISES DESCRIPTION <code>RpcError</code> <p>If an error occurs while listing public trades.</p> Source code in <code>frequenz/client/electricity_trading/_client.py</code> <pre><code>async def list_public_trades(\n    # pylint: disable=too-many-arguments, too-many-positional-arguments\n    self,\n    states: list[TradeState] | None = None,\n    delivery_period: DeliveryPeriod | None = None,\n    buy_delivery_area: DeliveryArea | None = None,\n    sell_delivery_area: DeliveryArea | None = None,\n    page_size: int | None = None,\n    timeout: timedelta | None = None,\n) -&gt; AsyncIterator[PublicTrade]:\n    \"\"\"\n    List all executed public orders with optional filters and pagination.\n\n    Args:\n        states: List of order states to filter by.\n        delivery_period: The delivery period to filter by.\n        buy_delivery_area: The buy delivery area to filter by.\n        sell_delivery_area: The sell delivery area to filter by.\n        page_size: The number of public trades to return per page.\n        timeout: Timeout duration, defaults to None.\n\n    Yields:\n        The list of public trades for each page.\n\n    Raises:\n        grpc.RpcError: If an error occurs while listing public trades.\n    \"\"\"\n    public_trade_filter = PublicTradeFilter(\n        states=states,\n        delivery_period=delivery_period,\n        buy_delivery_area=buy_delivery_area,\n        sell_delivery_area=sell_delivery_area,\n    )\n\n    request = electricity_trading_pb2.ListPublicTradesRequest(\n        filter=public_trade_filter.to_pb(),\n        pagination_params=(\n            Params(page_size=page_size).to_proto() if page_size else None\n        ),\n    )\n\n    while True:\n        try:\n            response = await cast(\n                Awaitable[electricity_trading_pb2.ListPublicTradesResponse],\n                grpc_call_with_timeout(\n                    self.stub.ListPublicTrades,\n                    request,\n                    metadata=self._metadata,\n                    timeout=timeout,\n                ),\n            )\n\n            for public_trade in response.public_trades:\n                yield PublicTrade.from_pb(public_trade)\n\n            if response.pagination_info.next_page_token:\n                request.pagination_params.CopyFrom(\n                    PaginationParams(\n                        page_token=response.pagination_info.next_page_token\n                    )\n                )\n            else:\n                break\n\n        except grpc.RpcError as e:\n            _logger.exception(\"Error occurred while listing public trades: %s\", e)\n            raise\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Client.stream_gridpool_orders","title":"stream_gridpool_orders  <code>async</code>","text":"<pre><code>stream_gridpool_orders(\n    gridpool_id: int,\n    order_states: list[OrderState] | None = None,\n    market_side: MarketSide | None = None,\n    delivery_area: DeliveryArea | None = None,\n    delivery_period: DeliveryPeriod | None = None,\n    tag: str | None = None,\n) -&gt; Receiver[OrderDetail]\n</code></pre> <p>Stream gridpool orders.</p> PARAMETER DESCRIPTION <code>gridpool_id</code> <p>ID of the gridpool to stream orders for.</p> <p> TYPE: <code>int</code> </p> <code>order_states</code> <p>List of order states to filter for.</p> <p> TYPE: <code>list[OrderState] | None</code> DEFAULT: <code>None</code> </p> <code>market_side</code> <p>Market side to filter for.</p> <p> TYPE: <code>MarketSide | None</code> DEFAULT: <code>None</code> </p> <code>delivery_area</code> <p>Delivery area to filter for.</p> <p> TYPE: <code>DeliveryArea | None</code> DEFAULT: <code>None</code> </p> <code>delivery_period</code> <p>Delivery period to filter for.</p> <p> TYPE: <code>DeliveryPeriod | None</code> DEFAULT: <code>None</code> </p> <code>tag</code> <p>Tag to filter for.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Receiver[OrderDetail]</code> <p>Async generator of orders.</p> RAISES DESCRIPTION <code>RpcError</code> <p>If an error occurs while streaming the orders.</p> Source code in <code>frequenz/client/electricity_trading/_client.py</code> <pre><code>async def stream_gridpool_orders(\n    # pylint: disable=too-many-arguments, too-many-positional-arguments\n    self,\n    gridpool_id: int,\n    order_states: list[OrderState] | None = None,\n    market_side: MarketSide | None = None,\n    delivery_area: DeliveryArea | None = None,\n    delivery_period: DeliveryPeriod | None = None,\n    tag: str | None = None,\n) -&gt; Receiver[OrderDetail]:\n    \"\"\"\n    Stream gridpool orders.\n\n    Args:\n        gridpool_id: ID of the gridpool to stream orders for.\n        order_states: List of order states to filter for.\n        market_side: Market side to filter for.\n        delivery_area: Delivery area to filter for.\n        delivery_period: Delivery period to filter for.\n        tag: Tag to filter for.\n\n    Returns:\n        Async generator of orders.\n\n    Raises:\n        grpc.RpcError: If an error occurs while streaming the orders.\n    \"\"\"\n    self.validate_params(delivery_period=delivery_period)\n\n    gridpool_order_filter = GridpoolOrderFilter(\n        order_states=order_states,\n        side=market_side,\n        delivery_area=delivery_area,\n        delivery_period=delivery_period,\n        tag=tag,\n    )\n\n    stream_key = (gridpool_id, gridpool_order_filter)\n\n    if stream_key not in self._gridpool_orders_streams:\n        try:\n            self._gridpool_orders_streams[stream_key] = GrpcStreamBroadcaster(\n                f\"electricity-trading-{stream_key}\",\n                lambda: self.stub.ReceiveGridpoolOrdersStream(\n                    electricity_trading_pb2.ReceiveGridpoolOrdersStreamRequest(\n                        gridpool_id=gridpool_id,\n                        filter=gridpool_order_filter.to_pb(),\n                    ),\n                    metadata=self._metadata,\n                ),\n                lambda response: OrderDetail.from_pb(response.order_detail),\n            )\n        except grpc.RpcError as e:\n            _logger.exception(\n                \"Error occurred while streaming gridpool orders: %s\", e\n            )\n            raise\n    return self._gridpool_orders_streams[stream_key].new_receiver()\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Client.stream_gridpool_trades","title":"stream_gridpool_trades  <code>async</code>","text":"<pre><code>stream_gridpool_trades(\n    gridpool_id: int,\n    trade_states: list[TradeState] | None = None,\n    trade_ids: list[int] | None = None,\n    market_side: MarketSide | None = None,\n    delivery_period: DeliveryPeriod | None = None,\n    delivery_area: DeliveryArea | None = None,\n) -&gt; Receiver[Trade]\n</code></pre> <p>Stream gridpool trades.</p> PARAMETER DESCRIPTION <code>gridpool_id</code> <p>The ID of the gridpool to stream trades for.</p> <p> TYPE: <code>int</code> </p> <code>trade_states</code> <p>List of trade states to filter for.</p> <p> TYPE: <code>list[TradeState] | None</code> DEFAULT: <code>None</code> </p> <code>trade_ids</code> <p>List of trade IDs to filter for.</p> <p> TYPE: <code>list[int] | None</code> DEFAULT: <code>None</code> </p> <code>market_side</code> <p>The market side to filter for.</p> <p> TYPE: <code>MarketSide | None</code> DEFAULT: <code>None</code> </p> <code>delivery_period</code> <p>The delivery period to filter for.</p> <p> TYPE: <code>DeliveryPeriod | None</code> DEFAULT: <code>None</code> </p> <code>delivery_area</code> <p>The delivery area to filter for.</p> <p> TYPE: <code>DeliveryArea | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Receiver[Trade]</code> <p>The gridpool trades streamer.</p> RAISES DESCRIPTION <code>RpcError</code> <p>If an error occurs while streaming gridpool trades.</p> Source code in <code>frequenz/client/electricity_trading/_client.py</code> <pre><code>async def stream_gridpool_trades(\n    # pylint: disable=too-many-arguments, too-many-positional-arguments\n    self,\n    gridpool_id: int,\n    trade_states: list[TradeState] | None = None,\n    trade_ids: list[int] | None = None,\n    market_side: MarketSide | None = None,\n    delivery_period: DeliveryPeriod | None = None,\n    delivery_area: DeliveryArea | None = None,\n) -&gt; Receiver[Trade]:\n    \"\"\"\n    Stream gridpool trades.\n\n    Args:\n        gridpool_id: The ID of the gridpool to stream trades for.\n        trade_states: List of trade states to filter for.\n        trade_ids: List of trade IDs to filter for.\n        market_side: The market side to filter for.\n        delivery_period: The delivery period to filter for.\n        delivery_area: The delivery area to filter for.\n\n    Returns:\n        The gridpool trades streamer.\n\n    Raises:\n        grpc.RpcError: If an error occurs while streaming gridpool trades.\n    \"\"\"\n    self.validate_params(delivery_period=delivery_period)\n\n    gridpool_trade_filter = GridpoolTradeFilter(\n        trade_states=trade_states,\n        trade_ids=trade_ids,\n        side=market_side,\n        delivery_period=delivery_period,\n        delivery_area=delivery_area,\n    )\n\n    stream_key = (gridpool_id, gridpool_trade_filter)\n\n    if stream_key not in self._gridpool_trades_streams:\n        try:\n            self._gridpool_trades_streams[stream_key] = GrpcStreamBroadcaster(\n                f\"electricity-trading-{stream_key}\",\n                lambda: self.stub.ReceiveGridpoolTradesStream(\n                    electricity_trading_pb2.ReceiveGridpoolTradesStreamRequest(\n                        gridpool_id=gridpool_id,\n                        filter=gridpool_trade_filter.to_pb(),\n                    ),\n                    metadata=self._metadata,\n                ),\n                lambda response: Trade.from_pb(response.trade),\n            )\n        except grpc.RpcError as e:\n            _logger.exception(\n                \"Error occurred while streaming gridpool trades: %s\", e\n            )\n            raise\n    return self._gridpool_trades_streams[stream_key].new_receiver()\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Client.stream_public_trades","title":"stream_public_trades  <code>async</code>","text":"<pre><code>stream_public_trades(\n    states: list[TradeState] | None = None,\n    delivery_period: DeliveryPeriod | None = None,\n    buy_delivery_area: DeliveryArea | None = None,\n    sell_delivery_area: DeliveryArea | None = None,\n) -&gt; Receiver[PublicTrade]\n</code></pre> <p>Stream public trades.</p> PARAMETER DESCRIPTION <code>states</code> <p>List of order states to filter for.</p> <p> TYPE: <code>list[TradeState] | None</code> DEFAULT: <code>None</code> </p> <code>delivery_period</code> <p>Delivery period to filter for.</p> <p> TYPE: <code>DeliveryPeriod | None</code> DEFAULT: <code>None</code> </p> <code>buy_delivery_area</code> <p>Buy delivery area to filter for.</p> <p> TYPE: <code>DeliveryArea | None</code> DEFAULT: <code>None</code> </p> <code>sell_delivery_area</code> <p>Sell delivery area to filter for.</p> <p> TYPE: <code>DeliveryArea | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Receiver[PublicTrade]</code> <p>Async generator of orders.</p> RAISES DESCRIPTION <code>RpcError</code> <p>If an error occurs while streaming public trades.</p> Source code in <code>frequenz/client/electricity_trading/_client.py</code> <pre><code>async def stream_public_trades(\n    self,\n    states: list[TradeState] | None = None,\n    delivery_period: DeliveryPeriod | None = None,\n    buy_delivery_area: DeliveryArea | None = None,\n    sell_delivery_area: DeliveryArea | None = None,\n) -&gt; Receiver[PublicTrade]:\n    \"\"\"\n    Stream public trades.\n\n    Args:\n        states: List of order states to filter for.\n        delivery_period: Delivery period to filter for.\n        buy_delivery_area: Buy delivery area to filter for.\n        sell_delivery_area: Sell delivery area to filter for.\n\n    Returns:\n        Async generator of orders.\n\n    Raises:\n        grpc.RpcError: If an error occurs while streaming public trades.\n    \"\"\"\n    self.validate_params(delivery_period=delivery_period)\n\n    public_trade_filter = PublicTradeFilter(\n        states=states,\n        delivery_period=delivery_period,\n        buy_delivery_area=buy_delivery_area,\n        sell_delivery_area=sell_delivery_area,\n    )\n\n    if public_trade_filter not in self._public_trades_streams:\n        try:\n            self._public_trades_streams[public_trade_filter] = (\n                GrpcStreamBroadcaster(\n                    f\"electricity-trading-{public_trade_filter}\",\n                    lambda: self.stub.ReceivePublicTradesStream(\n                        electricity_trading_pb2.ReceivePublicTradesStreamRequest(\n                            filter=public_trade_filter.to_pb(),\n                        ),\n                        metadata=self._metadata,\n                    ),\n                    lambda response: PublicTrade.from_pb(response.public_trade),\n                )\n            )\n        except grpc.RpcError as e:\n            _logger.exception(\"Error occurred while streaming public trades: %s\", e)\n            raise\n    return self._public_trades_streams[public_trade_filter].new_receiver()\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Client.update_gridpool_order","title":"update_gridpool_order  <code>async</code>","text":"<pre><code>update_gridpool_order(\n    gridpool_id: int,\n    order_id: int,\n    price: Price | None | _Sentinel = NO_VALUE,\n    quantity: Power | None | _Sentinel = NO_VALUE,\n    stop_price: Price | None | _Sentinel = NO_VALUE,\n    peak_price_delta: Price | None | _Sentinel = NO_VALUE,\n    display_quantity: Power | None | _Sentinel = NO_VALUE,\n    execution_option: (\n        OrderExecutionOption | None | _Sentinel\n    ) = NO_VALUE,\n    valid_until: datetime | None | _Sentinel = NO_VALUE,\n    payload: dict[str, Value] | None | _Sentinel = NO_VALUE,\n    tag: str | None | _Sentinel = NO_VALUE,\n    timeout: timedelta | None = None,\n) -&gt; OrderDetail\n</code></pre> <p>Update an existing order for a given Gridpool.</p> PARAMETER DESCRIPTION <code>gridpool_id</code> <p>ID of the Gridpool the order belongs to.</p> <p> TYPE: <code>int</code> </p> <code>order_id</code> <p>Order ID.</p> <p> TYPE: <code>int</code> </p> <code>price</code> <p>The updated limit price at which the contract is to be traded. This is the maximum price for a BUY order or the minimum price for a SELL order.</p> <p> TYPE: <code>Price | None | _Sentinel</code> DEFAULT: <code>NO_VALUE</code> </p> <code>quantity</code> <p>The updated quantity of the contract being traded, specified in MW.</p> <p> TYPE: <code>Power | None | _Sentinel</code> DEFAULT: <code>NO_VALUE</code> </p> <code>stop_price</code> <p>Applicable for STOP_LIMIT orders. This is the updated stop price that triggers the limit order.</p> <p> TYPE: <code>Price | None | _Sentinel</code> DEFAULT: <code>NO_VALUE</code> </p> <code>peak_price_delta</code> <p>Applicable for ICEBERG orders. This is the updated price difference between the peak price and the limit price.</p> <p> TYPE: <code>Price | None | _Sentinel</code> DEFAULT: <code>NO_VALUE</code> </p> <code>display_quantity</code> <p>Applicable for ICEBERG orders. This is the updated quantity of the order to be displayed in the order book.</p> <p> TYPE: <code>Power | None | _Sentinel</code> DEFAULT: <code>NO_VALUE</code> </p> <code>execution_option</code> <p>Updated execution options such as All or None, Fill or Kill, etc.</p> <p> TYPE: <code>OrderExecutionOption | None | _Sentinel</code> DEFAULT: <code>NO_VALUE</code> </p> <code>valid_until</code> <p>This is an updated timestamp defining the time after which the order should be cancelled if not filled. The timestamp is in UTC.</p> <p> TYPE: <code>datetime | None | _Sentinel</code> DEFAULT: <code>NO_VALUE</code> </p> <code>payload</code> <p>Updated user-defined payload individual to a specific order. This can be any data that the user wants to associate with the order.</p> <p> TYPE: <code>dict[str, Value] | None | _Sentinel</code> DEFAULT: <code>NO_VALUE</code> </p> <code>tag</code> <p>Updated user-defined tag to group related orders.</p> <p> TYPE: <code>str | None | _Sentinel</code> DEFAULT: <code>NO_VALUE</code> </p> <code>timeout</code> <p>Timeout duration, defaults to None.</p> <p> TYPE: <code>timedelta | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>OrderDetail</code> <p>The updated order.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If no fields to update are provided.</p> <code>RpcError</code> <p>An error occurred while updating the order.</p> Source code in <code>frequenz/client/electricity_trading/_client.py</code> <pre><code>async def update_gridpool_order(\n    # pylint: disable=too-many-arguments, too-many-positional-arguments, too-many-locals\n    self,\n    gridpool_id: int,\n    order_id: int,\n    price: Price | None | _Sentinel = NO_VALUE,\n    quantity: Power | None | _Sentinel = NO_VALUE,\n    stop_price: Price | None | _Sentinel = NO_VALUE,\n    peak_price_delta: Price | None | _Sentinel = NO_VALUE,\n    display_quantity: Power | None | _Sentinel = NO_VALUE,\n    execution_option: OrderExecutionOption | None | _Sentinel = NO_VALUE,\n    valid_until: datetime | None | _Sentinel = NO_VALUE,\n    payload: dict[str, struct_pb2.Value] | None | _Sentinel = NO_VALUE,\n    tag: str | None | _Sentinel = NO_VALUE,\n    timeout: timedelta | None = None,\n) -&gt; OrderDetail:\n    \"\"\"\n    Update an existing order for a given Gridpool.\n\n    Args:\n        gridpool_id: ID of the Gridpool the order belongs to.\n        order_id: Order ID.\n        price: The updated limit price at which the contract is to be traded.\n            This is the maximum price for a BUY order or the minimum price for a SELL order.\n        quantity: The updated quantity of the contract being traded, specified in MW.\n        stop_price: Applicable for STOP_LIMIT orders. This is the updated stop price that\n            triggers the limit order.\n        peak_price_delta: Applicable for ICEBERG orders. This is the updated price difference\n            between the peak price and the limit price.\n        display_quantity: Applicable for ICEBERG orders. This is the updated quantity of the\n            order to be displayed in the order book.\n        execution_option: Updated execution options such as All or None, Fill or Kill, etc.\n        valid_until: This is an updated timestamp defining the time after which the order\n            should be cancelled if not filled. The timestamp is in UTC.\n        payload: Updated user-defined payload individual to a specific order. This can be any\n            data that the user wants to associate with the order.\n        tag: Updated user-defined tag to group related orders.\n        timeout: Timeout duration, defaults to None.\n\n    Returns:\n        The updated order.\n\n    Raises:\n        ValueError: If no fields to update are provided.\n        grpc.RpcError: An error occurred while updating the order.\n    \"\"\"\n    self.validate_params(\n        price=price,\n        quantity=quantity,\n        stop_price=stop_price,\n        peak_price_delta=peak_price_delta,\n        display_quantity=display_quantity,\n        valid_until=valid_until,\n        execution_option=execution_option,\n    )\n\n    params = {\n        \"price\": price,\n        \"quantity\": quantity,\n        \"stop_price\": stop_price,\n        \"peak_price_delta\": peak_price_delta,\n        \"display_quantity\": display_quantity,\n        \"execution_option\": execution_option,\n        \"valid_until\": valid_until,\n        \"payload\": payload,\n        \"tag\": tag,\n    }\n\n    if all(value is NO_VALUE for value in params.values()):\n        raise ValueError(\"At least one field to update must be provided.\")\n\n    paths = [param for param, value in params.items() if value is not NO_VALUE]\n\n    # Field mask specifying which fields should be updated\n    # This is used so that we can update parameters with None values\n    update_mask = field_mask_pb2.FieldMask(paths=paths)\n\n    update_order_fields = UpdateOrder(\n        price=None if price is NO_VALUE else price,  # type: ignore\n        quantity=None if quantity is NO_VALUE else quantity,  # type: ignore\n        stop_price=None if stop_price is NO_VALUE else stop_price,  # type: ignore\n        peak_price_delta=(\n            None if peak_price_delta is NO_VALUE else peak_price_delta  # type: ignore\n        ),\n        display_quantity=(\n            None if display_quantity is NO_VALUE else display_quantity  # type: ignore\n        ),\n        execution_option=(\n            None if execution_option is NO_VALUE else execution_option  # type: ignore\n        ),\n        valid_until=(\n            None if valid_until is NO_VALUE else valid_until  # type: ignore\n        ),\n        payload=None if payload is NO_VALUE else payload,  # type: ignore\n        tag=None if tag is NO_VALUE else tag,  # type: ignore\n    )\n\n    try:\n        response = await cast(\n            Awaitable[electricity_trading_pb2.UpdateGridpoolOrderResponse],\n            grpc_call_with_timeout(\n                self.stub.UpdateGridpoolOrder,\n                electricity_trading_pb2.UpdateGridpoolOrderRequest(\n                    gridpool_id=gridpool_id,\n                    order_id=order_id,\n                    update_order_fields=update_order_fields.to_pb(),\n                    update_mask=update_mask,\n                ),\n                metadata=self._metadata,\n                timeout=timeout,\n            ),\n        )\n        return OrderDetail.from_pb(response.order_detail)\n\n    except grpc.RpcError as e:\n        _logger.exception(\"Error occurred while updating gridpool order: %s\", e)\n        raise\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Client.validate_params","title":"validate_params","text":"<pre><code>validate_params(\n    price: Price | None | _Sentinel = NO_VALUE,\n    quantity: Power | None | _Sentinel = NO_VALUE,\n    stop_price: Price | None | _Sentinel = NO_VALUE,\n    peak_price_delta: Price | None | _Sentinel = NO_VALUE,\n    display_quantity: Power | None | _Sentinel = NO_VALUE,\n    delivery_period: DeliveryPeriod | None = None,\n    valid_until: datetime | None | _Sentinel = NO_VALUE,\n    execution_option: (\n        OrderExecutionOption | None | _Sentinel\n    ) = NO_VALUE,\n    order_type: OrderType | None = None,\n) -&gt; None\n</code></pre> <p>Validate the parameters of an order.</p> <p>This method ensures the following: - Price and quantity values have the correct number of decimal places and are positive. - The delivery_start and valid_until values are in the future.</p> PARAMETER DESCRIPTION <code>price</code> <p>The price of the order.</p> <p> TYPE: <code>Price | None | _Sentinel</code> DEFAULT: <code>NO_VALUE</code> </p> <code>quantity</code> <p>The quantity of the order.</p> <p> TYPE: <code>Power | None | _Sentinel</code> DEFAULT: <code>NO_VALUE</code> </p> <code>stop_price</code> <p>The stop price of the order.</p> <p> TYPE: <code>Price | None | _Sentinel</code> DEFAULT: <code>NO_VALUE</code> </p> <code>peak_price_delta</code> <p>The peak price delta of the order.</p> <p> TYPE: <code>Price | None | _Sentinel</code> DEFAULT: <code>NO_VALUE</code> </p> <code>display_quantity</code> <p>The display quantity of the order.</p> <p> TYPE: <code>Power | None | _Sentinel</code> DEFAULT: <code>NO_VALUE</code> </p> <code>delivery_period</code> <p>The delivery period of the order.</p> <p> TYPE: <code>DeliveryPeriod | None</code> DEFAULT: <code>None</code> </p> <code>valid_until</code> <p>The valid until of the order.</p> <p> TYPE: <code>datetime | None | _Sentinel</code> DEFAULT: <code>NO_VALUE</code> </p> <code>execution_option</code> <p>The execution option of the order.</p> <p> TYPE: <code>OrderExecutionOption | None | _Sentinel</code> DEFAULT: <code>NO_VALUE</code> </p> <code>order_type</code> <p>The order type.</p> <p> TYPE: <code>OrderType | None</code> DEFAULT: <code>None</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If the parameters are invalid.</p> <code>NotImplementedError</code> <p>If the order type is not supported.</p> Source code in <code>frequenz/client/electricity_trading/_client.py</code> <pre><code>def validate_params(\n    # pylint: disable=too-many-arguments, too-many-positional-arguments, too-many-branches\n    self,\n    price: Price | None | _Sentinel = NO_VALUE,\n    quantity: Power | None | _Sentinel = NO_VALUE,\n    stop_price: Price | None | _Sentinel = NO_VALUE,\n    peak_price_delta: Price | None | _Sentinel = NO_VALUE,\n    display_quantity: Power | None | _Sentinel = NO_VALUE,\n    delivery_period: DeliveryPeriod | None = None,\n    valid_until: datetime | None | _Sentinel = NO_VALUE,\n    execution_option: OrderExecutionOption | None | _Sentinel = NO_VALUE,\n    order_type: OrderType | None = None,\n) -&gt; None:\n    \"\"\"\n    Validate the parameters of an order.\n\n    This method ensures the following:\n    - Price and quantity values have the correct number of decimal places and are positive.\n    - The delivery_start and valid_until values are in the future.\n\n    Args:\n        price: The price of the order.\n        quantity: The quantity of the order.\n        stop_price: The stop price of the order.\n        peak_price_delta: The peak price delta of the order.\n        display_quantity: The display quantity of the order.\n        delivery_period: The delivery period of the order.\n        valid_until: The valid until of the order.\n        execution_option: The execution option of the order.\n        order_type: The order type.\n\n    Raises:\n        ValueError: If the parameters are invalid.\n        NotImplementedError: If the order type is not supported.\n    \"\"\"\n    if not isinstance(price, _Sentinel) and price is not None:\n        if price.amount &lt; MIN_PRICE or price.amount &gt; MAX_PRICE:\n            raise ValueError(f\"Price must be between {MIN_PRICE} and {MAX_PRICE}.\")\n        validate_decimal_places(price.amount, PRECISION_DECIMAL_PRICE, \"price\")\n    if not isinstance(quantity, _Sentinel) and quantity is not None:\n        if quantity.mw &lt;= 0:\n            raise ValueError(\"Quantity must be strictly positive\")\n        if quantity.mw &lt; MIN_QUANTITY_MW:\n            raise ValueError(f\"Quantity must be at least {MIN_QUANTITY_MW} MW.\")\n        validate_decimal_places(quantity.mw, PRECISION_DECIMAL_QUANTITY, \"quantity\")\n    if not isinstance(stop_price, _Sentinel) and stop_price is not None:\n        raise NotImplementedError(\n            \"STOP_LIMIT orders are not supported yet, so stop_price cannot be set.\"\n        )\n    if not isinstance(peak_price_delta, _Sentinel) and peak_price_delta is not None:\n        raise NotImplementedError(\n            \"ICEBERG orders are not supported yet, so peak_price_delta cannot be set.\"\n        )\n    if not isinstance(display_quantity, _Sentinel) and display_quantity is not None:\n        raise NotImplementedError(\n            \"ICEBERG orders are not supported yet, so display_quantity cannot be set.\"\n        )\n    if delivery_period is not None:\n        if delivery_period.start &lt; datetime.now(timezone.utc):\n            raise ValueError(\"delivery_period must be in the future\")\n    if not isinstance(valid_until, _Sentinel) and valid_until is not None:\n        if (\n            not isinstance(execution_option, _Sentinel)\n            and execution_option is not None\n        ):\n            if execution_option in [\n                OrderExecutionOption.AON,\n                OrderExecutionOption.FOK,\n                OrderExecutionOption.IOC,\n            ]:\n                raise ValueError(\n                    \"valid_until must be None when execution_option is set to AON, FOK, or IOC\"\n                )\n\n        if valid_until &lt; datetime.now(timezone.utc):\n            raise ValueError(\"valid_until must be in the future\")\n    if order_type is not None:\n        if order_type != OrderType.LIMIT:\n            raise NotImplementedError(\"Currently only limit orders are supported.\")\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Currency","title":"frequenz.client.electricity_trading.Currency","text":"<p>               Bases: <code>Enum</code></p> <p>List of supported currencies.</p> <p>New currencies can be added to this enum to support additional markets.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>class Currency(enum.Enum):\n    \"\"\"\n    List of supported currencies.\n\n    New currencies can be added to this enum to support additional markets.\n    \"\"\"\n\n    UNSPECIFIED = price_pb2.Price.Currency.CURRENCY_UNSPECIFIED\n    \"\"\"Currency is not specified.\"\"\"\n\n    USD = price_pb2.Price.Currency.CURRENCY_USD\n\n    CAD = price_pb2.Price.Currency.CURRENCY_CAD\n\n    EUR = price_pb2.Price.Currency.CURRENCY_EUR\n\n    GBP = price_pb2.Price.Currency.CURRENCY_GBP\n\n    CHF = price_pb2.Price.Currency.CURRENCY_CHF\n\n    CNY = price_pb2.Price.Currency.CURRENCY_CNY\n\n    JPY = price_pb2.Price.Currency.CURRENCY_JPY\n\n    AUD = price_pb2.Price.Currency.CURRENCY_AUD\n\n    NZD = price_pb2.Price.Currency.CURRENCY_NZD\n\n    SGD = price_pb2.Price.Currency.CURRENCY_SGD\n\n    @classmethod\n    def from_pb(cls, currency: price_pb2.Price.Currency.ValueType) -&gt; \"Currency\":\n        \"\"\"Convert a protobuf Currency value to Currency enum.\n\n        Args:\n            currency: Currency to convert.\n\n        Returns:\n            Enum value corresponding to the protobuf message.\n        \"\"\"\n        if not any(e.value == currency for e in cls):\n            _logger.warning(\"Unknown currency %s. Returning UNSPECIFIED.\", currency)\n            return cls.UNSPECIFIED\n\n        return cls(currency)\n\n    def to_pb(self) -&gt; price_pb2.Price.Currency.ValueType:\n        \"\"\"Convert a Currency object to protobuf Currency.\n\n        Returns:\n            Protobuf message corresponding to the Currency object.\n        \"\"\"\n        return price_pb2.Price.Currency.ValueType(self.value)\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Currency-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Currency.UNSPECIFIED","title":"UNSPECIFIED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>UNSPECIFIED = CURRENCY_UNSPECIFIED\n</code></pre> <p>Currency is not specified.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Currency-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Currency.from_pb","title":"from_pb  <code>classmethod</code>","text":"<pre><code>from_pb(currency: ValueType) -&gt; 'Currency'\n</code></pre> <p>Convert a protobuf Currency value to Currency enum.</p> PARAMETER DESCRIPTION <code>currency</code> <p>Currency to convert.</p> <p> TYPE: <code>ValueType</code> </p> RETURNS DESCRIPTION <code>'Currency'</code> <p>Enum value corresponding to the protobuf message.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>@classmethod\ndef from_pb(cls, currency: price_pb2.Price.Currency.ValueType) -&gt; \"Currency\":\n    \"\"\"Convert a protobuf Currency value to Currency enum.\n\n    Args:\n        currency: Currency to convert.\n\n    Returns:\n        Enum value corresponding to the protobuf message.\n    \"\"\"\n    if not any(e.value == currency for e in cls):\n        _logger.warning(\"Unknown currency %s. Returning UNSPECIFIED.\", currency)\n        return cls.UNSPECIFIED\n\n    return cls(currency)\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Currency.to_pb","title":"to_pb","text":"<pre><code>to_pb() -&gt; ValueType\n</code></pre> <p>Convert a Currency object to protobuf Currency.</p> RETURNS DESCRIPTION <code>ValueType</code> <p>Protobuf message corresponding to the Currency object.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>def to_pb(self) -&gt; price_pb2.Price.Currency.ValueType:\n    \"\"\"Convert a Currency object to protobuf Currency.\n\n    Returns:\n        Protobuf message corresponding to the Currency object.\n    \"\"\"\n    return price_pb2.Price.Currency.ValueType(self.value)\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.DeliveryArea","title":"frequenz.client.electricity_trading.DeliveryArea  <code>dataclass</code>","text":"<p>Geographical or administrative region.</p> <p>These are, usually defined and maintained by a Transmission System Operator (TSO), where electricity deliveries for a contract occur.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>@dataclass(frozen=True)\nclass DeliveryArea:\n    \"\"\"\n    Geographical or administrative region.\n\n    These are, usually defined and maintained by a Transmission System Operator (TSO), where\n    electricity deliveries for a contract occur.\n    \"\"\"\n\n    code: str\n    \"\"\"Code representing the unique identifier for the delivery area.\"\"\"\n\n    code_type: EnergyMarketCodeType\n    \"\"\"Type of code used for identifying the delivery area itself.\"\"\"\n\n    @classmethod\n    def from_pb(cls, delivery_area: delivery_area_pb2.DeliveryArea) -&gt; Self:\n        \"\"\"Convert a protobuf DeliveryArea to DeliveryArea object.\n\n        Args:\n            delivery_area: DeliveryArea to convert.\n\n        Returns:\n            DeliveryArea object corresponding to the protobuf message.\n        \"\"\"\n        return cls(\n            code=delivery_area.code,\n            code_type=EnergyMarketCodeType.from_pb(delivery_area.code_type),\n        )\n\n    def to_pb(self) -&gt; delivery_area_pb2.DeliveryArea:\n        \"\"\"Convert a DeliveryArea object to protobuf DeliveryArea.\n\n        Returns:\n            Protobuf message corresponding to the DeliveryArea object.\n        \"\"\"\n        return delivery_area_pb2.DeliveryArea(\n            code=self.code, code_type=self.code_type.to_pb()\n        )\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.DeliveryArea-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.DeliveryArea.code","title":"code  <code>instance-attribute</code>","text":"<pre><code>code: str\n</code></pre> <p>Code representing the unique identifier for the delivery area.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.DeliveryArea.code_type","title":"code_type  <code>instance-attribute</code>","text":"<pre><code>code_type: EnergyMarketCodeType\n</code></pre> <p>Type of code used for identifying the delivery area itself.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.DeliveryArea-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.DeliveryArea.from_pb","title":"from_pb  <code>classmethod</code>","text":"<pre><code>from_pb(delivery_area: DeliveryArea) -&gt; Self\n</code></pre> <p>Convert a protobuf DeliveryArea to DeliveryArea object.</p> PARAMETER DESCRIPTION <code>delivery_area</code> <p>DeliveryArea to convert.</p> <p> TYPE: <code>DeliveryArea</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>DeliveryArea object corresponding to the protobuf message.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>@classmethod\ndef from_pb(cls, delivery_area: delivery_area_pb2.DeliveryArea) -&gt; Self:\n    \"\"\"Convert a protobuf DeliveryArea to DeliveryArea object.\n\n    Args:\n        delivery_area: DeliveryArea to convert.\n\n    Returns:\n        DeliveryArea object corresponding to the protobuf message.\n    \"\"\"\n    return cls(\n        code=delivery_area.code,\n        code_type=EnergyMarketCodeType.from_pb(delivery_area.code_type),\n    )\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.DeliveryArea.to_pb","title":"to_pb","text":"<pre><code>to_pb() -&gt; DeliveryArea\n</code></pre> <p>Convert a DeliveryArea object to protobuf DeliveryArea.</p> RETURNS DESCRIPTION <code>DeliveryArea</code> <p>Protobuf message corresponding to the DeliveryArea object.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>def to_pb(self) -&gt; delivery_area_pb2.DeliveryArea:\n    \"\"\"Convert a DeliveryArea object to protobuf DeliveryArea.\n\n    Returns:\n        Protobuf message corresponding to the DeliveryArea object.\n    \"\"\"\n    return delivery_area_pb2.DeliveryArea(\n        code=self.code, code_type=self.code_type.to_pb()\n    )\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.DeliveryDuration","title":"frequenz.client.electricity_trading.DeliveryDuration","text":"<p>               Bases: <code>Enum</code></p> <p>Specifies the time increment, in minutes, used for electricity deliveries and trading.</p> <p>These durations serve as the basis for defining the delivery period in contracts, and they dictate how energy is scheduled and delivered to meet contractual obligations.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>class DeliveryDuration(enum.Enum):\n    \"\"\"\n    Specifies the time increment, in minutes, used for electricity deliveries and trading.\n\n    These durations serve as the basis for defining the delivery period in contracts, and they\n    dictate how energy is scheduled and delivered to meet contractual obligations.\n    \"\"\"\n\n    UNSPECIFIED = delivery_duration_pb2.DeliveryDuration.DELIVERY_DURATION_UNSPECIFIED\n    \"\"\"Default value, indicates that the duration is unspecified.\"\"\"\n\n    MINUTES_5 = delivery_duration_pb2.DeliveryDuration.DELIVERY_DURATION_5\n    \"\"\"5-minute duration.\"\"\"\n\n    MINUTES_15 = delivery_duration_pb2.DeliveryDuration.DELIVERY_DURATION_15\n    \"\"\"15-minute contract duration.\"\"\"\n\n    MINUTES_30 = delivery_duration_pb2.DeliveryDuration.DELIVERY_DURATION_30\n    \"\"\"30-minute contract duration.\"\"\"\n\n    MINUTES_60 = delivery_duration_pb2.DeliveryDuration.DELIVERY_DURATION_60\n    \"\"\"1-hour contract duration.\"\"\"\n\n    @classmethod\n    def from_pb(\n        cls, delivery_duration: delivery_duration_pb2.DeliveryDuration.ValueType\n    ) -&gt; \"DeliveryDuration\":\n        \"\"\"Convert a protobuf DeliveryDuration value to DeliveryDuration enum.\n\n        Args:\n            delivery_duration: Delivery duration to convert.\n\n        Returns:\n            Enum value corresponding to the protobuf message.\n        \"\"\"\n        if not any(e.value == delivery_duration for e in cls):\n            _logger.warning(\n                \"Unknown delivery duration %s. Returning UNSPECIFIED.\",\n                delivery_duration,\n            )\n            return cls.UNSPECIFIED\n\n        return cls(delivery_duration)\n\n    def to_pb(self) -&gt; delivery_duration_pb2.DeliveryDuration.ValueType:\n        \"\"\"Convert a DeliveryDuration object to protobuf DeliveryDuration.\n\n        Returns:\n            Protobuf message corresponding to the DeliveryDuration object.\n        \"\"\"\n        return delivery_duration_pb2.DeliveryDuration.ValueType(self.value)\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.DeliveryDuration-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.DeliveryDuration.MINUTES_15","title":"MINUTES_15  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MINUTES_15 = DELIVERY_DURATION_15\n</code></pre> <p>15-minute contract duration.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.DeliveryDuration.MINUTES_30","title":"MINUTES_30  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MINUTES_30 = DELIVERY_DURATION_30\n</code></pre> <p>30-minute contract duration.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.DeliveryDuration.MINUTES_5","title":"MINUTES_5  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MINUTES_5 = DELIVERY_DURATION_5\n</code></pre> <p>5-minute duration.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.DeliveryDuration.MINUTES_60","title":"MINUTES_60  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MINUTES_60 = DELIVERY_DURATION_60\n</code></pre> <p>1-hour contract duration.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.DeliveryDuration.UNSPECIFIED","title":"UNSPECIFIED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>UNSPECIFIED = DELIVERY_DURATION_UNSPECIFIED\n</code></pre> <p>Default value, indicates that the duration is unspecified.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.DeliveryDuration-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.DeliveryDuration.from_pb","title":"from_pb  <code>classmethod</code>","text":"<pre><code>from_pb(delivery_duration: ValueType) -&gt; 'DeliveryDuration'\n</code></pre> <p>Convert a protobuf DeliveryDuration value to DeliveryDuration enum.</p> PARAMETER DESCRIPTION <code>delivery_duration</code> <p>Delivery duration to convert.</p> <p> TYPE: <code>ValueType</code> </p> RETURNS DESCRIPTION <code>'DeliveryDuration'</code> <p>Enum value corresponding to the protobuf message.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>@classmethod\ndef from_pb(\n    cls, delivery_duration: delivery_duration_pb2.DeliveryDuration.ValueType\n) -&gt; \"DeliveryDuration\":\n    \"\"\"Convert a protobuf DeliveryDuration value to DeliveryDuration enum.\n\n    Args:\n        delivery_duration: Delivery duration to convert.\n\n    Returns:\n        Enum value corresponding to the protobuf message.\n    \"\"\"\n    if not any(e.value == delivery_duration for e in cls):\n        _logger.warning(\n            \"Unknown delivery duration %s. Returning UNSPECIFIED.\",\n            delivery_duration,\n        )\n        return cls.UNSPECIFIED\n\n    return cls(delivery_duration)\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.DeliveryDuration.to_pb","title":"to_pb","text":"<pre><code>to_pb() -&gt; ValueType\n</code></pre> <p>Convert a DeliveryDuration object to protobuf DeliveryDuration.</p> RETURNS DESCRIPTION <code>ValueType</code> <p>Protobuf message corresponding to the DeliveryDuration object.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>def to_pb(self) -&gt; delivery_duration_pb2.DeliveryDuration.ValueType:\n    \"\"\"Convert a DeliveryDuration object to protobuf DeliveryDuration.\n\n    Returns:\n        Protobuf message corresponding to the DeliveryDuration object.\n    \"\"\"\n    return delivery_duration_pb2.DeliveryDuration.ValueType(self.value)\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.DeliveryPeriod","title":"frequenz.client.electricity_trading.DeliveryPeriod","text":"<p>Time period during which the contract is delivered.</p> <p>It is defined by a start timestamp and a duration.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>class DeliveryPeriod:\n    \"\"\"\n    Time period during which the contract is delivered.\n\n    It is defined by a start timestamp and a duration.\n    \"\"\"\n\n    start: datetime\n    \"\"\"Start UTC timestamp represents the beginning of the delivery period.\n        This timestamp is inclusive, meaning that the delivery period starts\n        from this point in time.\"\"\"\n\n    duration: DeliveryDuration\n    \"\"\"The length of the delivery period.\"\"\"\n\n    def __init__(\n        self,\n        start: datetime,\n        duration: timedelta,\n    ) -&gt; None:\n        \"\"\"\n        Initialize the DeliveryPeriod object.\n\n        Args:\n            start: Start UTC timestamp represents the beginning of the delivery period.\n            duration: The length of the delivery period.\n\n        Raises:\n            ValueError: If the start timestamp does not have a timezone.\n                        or if the duration is not 5, 15, 30, or 60 minutes.\n        \"\"\"\n        if start.tzinfo is None:\n            raise ValueError(\"Start timestamp must have a timezone.\")\n        if start.tzinfo != timezone.utc:\n            _logger.warning(\n                \"Start timestamp is not in UTC timezone. Converting to UTC.\"\n            )\n            start = start.astimezone(timezone.utc)\n        self.start = start\n\n        minutes = duration.total_seconds() / 60\n        match minutes:\n            case 5:\n                self.duration = DeliveryDuration.MINUTES_5\n            case 15:\n                self.duration = DeliveryDuration.MINUTES_15\n            case 30:\n                self.duration = DeliveryDuration.MINUTES_30\n            case 60:\n                self.duration = DeliveryDuration.MINUTES_60\n            case _:\n                raise ValueError(\n                    \"Invalid duration value. Duration must be 5, 15, 30, or 60 minutes.\"\n                )\n\n    def __hash__(self) -&gt; int:\n        \"\"\"\n        Create hash of the DeliveryPeriod object.\n\n        Returns:\n            Hash of the DeliveryPeriod object.\n        \"\"\"\n        return hash((self.start, self.duration))\n\n    def __eq__(\n        self,\n        other: object,\n    ) -&gt; bool:\n        \"\"\"Check if two DeliveryPeriod objects are equal.\"\"\"\n        if not isinstance(other, DeliveryPeriod):\n            return NotImplemented\n\n        return self.start == other.start and self.duration == other.duration\n\n    def __str__(self) -&gt; str:\n        \"\"\"\n        Return string representation of the DeliveryPeriod object.\n\n        Returns:\n            String representation of the DeliveryPeriod object.\n        \"\"\"\n        duration_map = {\n            DeliveryDuration.MINUTES_5: \"5min\",\n            DeliveryDuration.MINUTES_15: \"15min\",\n            DeliveryDuration.MINUTES_30: \"30min\",\n            DeliveryDuration.MINUTES_60: \"60min\",\n        }\n        duration_str = duration_map.get(self.duration, \"Unknown duration\")\n        start_str = self.start.strftime(\"%Y-%m-%d %H:%M:%S %Z\")\n        return f\"DeliveryPeriod(start={start_str}, duration={duration_str})\"\n\n    def __repr__(self) -&gt; str:\n        \"\"\"\n        Developer-friendly representation of the DeliveryPeriod object.\n\n        Returns:\n            Developer-friendly representation of the DeliveryPeriod object.\n        \"\"\"\n        return self.__str__()\n\n    @classmethod\n    def from_pb(cls, delivery_period: delivery_duration_pb2.DeliveryPeriod) -&gt; Self:\n        \"\"\"Convert a protobuf DeliveryPeriod to DeliveryPeriod object.\n\n        Args:\n            delivery_period: DeliveryPeriod to convert.\n\n        Returns:\n            DeliveryPeriod object corresponding to the protobuf message.\n\n        Raises:\n            ValueError: If the duration is not 5, 15, 30, or 60 minutes.\n        \"\"\"\n        start = delivery_period.start.ToDatetime(tzinfo=timezone.utc)\n        delivery_duration_enum = DeliveryDuration.from_pb(delivery_period.duration)\n\n        match delivery_duration_enum:\n            case DeliveryDuration.MINUTES_5:\n                duration = timedelta(minutes=5)\n            case DeliveryDuration.MINUTES_15:\n                duration = timedelta(minutes=15)\n            case DeliveryDuration.MINUTES_30:\n                duration = timedelta(minutes=30)\n            case DeliveryDuration.MINUTES_60:\n                duration = timedelta(minutes=60)\n            case _:\n                raise ValueError(\n                    \"Invalid duration value. Duration must be 5, 15, 30, or 60 minutes.\"\n                )\n        return cls(start=start, duration=duration)\n\n    def to_pb(self) -&gt; delivery_duration_pb2.DeliveryPeriod:\n        \"\"\"Convert a DeliveryPeriod object to protobuf DeliveryPeriod.\n\n        Returns:\n            Protobuf message corresponding to the DeliveryPeriod object.\n        \"\"\"\n        start = timestamp_pb2.Timestamp()\n        start.FromDatetime(self.start)\n        return delivery_duration_pb2.DeliveryPeriod(\n            start=start,\n            duration=self.duration.to_pb(),\n        )\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.DeliveryPeriod-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.DeliveryPeriod.duration","title":"duration  <code>instance-attribute</code>","text":"<pre><code>duration: DeliveryDuration = MINUTES_60\n</code></pre> <p>The length of the delivery period.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.DeliveryPeriod.start","title":"start  <code>instance-attribute</code>","text":"<pre><code>start: datetime = start\n</code></pre> <p>Start UTC timestamp represents the beginning of the delivery period. This timestamp is inclusive, meaning that the delivery period starts from this point in time.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.DeliveryPeriod-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.DeliveryPeriod.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: object) -&gt; bool\n</code></pre> <p>Check if two DeliveryPeriod objects are equal.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>def __eq__(\n    self,\n    other: object,\n) -&gt; bool:\n    \"\"\"Check if two DeliveryPeriod objects are equal.\"\"\"\n    if not isinstance(other, DeliveryPeriod):\n        return NotImplemented\n\n    return self.start == other.start and self.duration == other.duration\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.DeliveryPeriod.__hash__","title":"__hash__","text":"<pre><code>__hash__() -&gt; int\n</code></pre> <p>Create hash of the DeliveryPeriod object.</p> RETURNS DESCRIPTION <code>int</code> <p>Hash of the DeliveryPeriod object.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>def __hash__(self) -&gt; int:\n    \"\"\"\n    Create hash of the DeliveryPeriod object.\n\n    Returns:\n        Hash of the DeliveryPeriod object.\n    \"\"\"\n    return hash((self.start, self.duration))\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.DeliveryPeriod.__init__","title":"__init__","text":"<pre><code>__init__(start: datetime, duration: timedelta) -&gt; None\n</code></pre> <p>Initialize the DeliveryPeriod object.</p> PARAMETER DESCRIPTION <code>start</code> <p>Start UTC timestamp represents the beginning of the delivery period.</p> <p> TYPE: <code>datetime</code> </p> <code>duration</code> <p>The length of the delivery period.</p> <p> TYPE: <code>timedelta</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If the start timestamp does not have a timezone.         or if the duration is not 5, 15, 30, or 60 minutes.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>def __init__(\n    self,\n    start: datetime,\n    duration: timedelta,\n) -&gt; None:\n    \"\"\"\n    Initialize the DeliveryPeriod object.\n\n    Args:\n        start: Start UTC timestamp represents the beginning of the delivery period.\n        duration: The length of the delivery period.\n\n    Raises:\n        ValueError: If the start timestamp does not have a timezone.\n                    or if the duration is not 5, 15, 30, or 60 minutes.\n    \"\"\"\n    if start.tzinfo is None:\n        raise ValueError(\"Start timestamp must have a timezone.\")\n    if start.tzinfo != timezone.utc:\n        _logger.warning(\n            \"Start timestamp is not in UTC timezone. Converting to UTC.\"\n        )\n        start = start.astimezone(timezone.utc)\n    self.start = start\n\n    minutes = duration.total_seconds() / 60\n    match minutes:\n        case 5:\n            self.duration = DeliveryDuration.MINUTES_5\n        case 15:\n            self.duration = DeliveryDuration.MINUTES_15\n        case 30:\n            self.duration = DeliveryDuration.MINUTES_30\n        case 60:\n            self.duration = DeliveryDuration.MINUTES_60\n        case _:\n            raise ValueError(\n                \"Invalid duration value. Duration must be 5, 15, 30, or 60 minutes.\"\n            )\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.DeliveryPeriod.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Developer-friendly representation of the DeliveryPeriod object.</p> RETURNS DESCRIPTION <code>str</code> <p>Developer-friendly representation of the DeliveryPeriod object.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"\n    Developer-friendly representation of the DeliveryPeriod object.\n\n    Returns:\n        Developer-friendly representation of the DeliveryPeriod object.\n    \"\"\"\n    return self.__str__()\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.DeliveryPeriod.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return string representation of the DeliveryPeriod object.</p> RETURNS DESCRIPTION <code>str</code> <p>String representation of the DeliveryPeriod object.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"\n    Return string representation of the DeliveryPeriod object.\n\n    Returns:\n        String representation of the DeliveryPeriod object.\n    \"\"\"\n    duration_map = {\n        DeliveryDuration.MINUTES_5: \"5min\",\n        DeliveryDuration.MINUTES_15: \"15min\",\n        DeliveryDuration.MINUTES_30: \"30min\",\n        DeliveryDuration.MINUTES_60: \"60min\",\n    }\n    duration_str = duration_map.get(self.duration, \"Unknown duration\")\n    start_str = self.start.strftime(\"%Y-%m-%d %H:%M:%S %Z\")\n    return f\"DeliveryPeriod(start={start_str}, duration={duration_str})\"\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.DeliveryPeriod.from_pb","title":"from_pb  <code>classmethod</code>","text":"<pre><code>from_pb(delivery_period: DeliveryPeriod) -&gt; Self\n</code></pre> <p>Convert a protobuf DeliveryPeriod to DeliveryPeriod object.</p> PARAMETER DESCRIPTION <code>delivery_period</code> <p>DeliveryPeriod to convert.</p> <p> TYPE: <code>DeliveryPeriod</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>DeliveryPeriod object corresponding to the protobuf message.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the duration is not 5, 15, 30, or 60 minutes.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>@classmethod\ndef from_pb(cls, delivery_period: delivery_duration_pb2.DeliveryPeriod) -&gt; Self:\n    \"\"\"Convert a protobuf DeliveryPeriod to DeliveryPeriod object.\n\n    Args:\n        delivery_period: DeliveryPeriod to convert.\n\n    Returns:\n        DeliveryPeriod object corresponding to the protobuf message.\n\n    Raises:\n        ValueError: If the duration is not 5, 15, 30, or 60 minutes.\n    \"\"\"\n    start = delivery_period.start.ToDatetime(tzinfo=timezone.utc)\n    delivery_duration_enum = DeliveryDuration.from_pb(delivery_period.duration)\n\n    match delivery_duration_enum:\n        case DeliveryDuration.MINUTES_5:\n            duration = timedelta(minutes=5)\n        case DeliveryDuration.MINUTES_15:\n            duration = timedelta(minutes=15)\n        case DeliveryDuration.MINUTES_30:\n            duration = timedelta(minutes=30)\n        case DeliveryDuration.MINUTES_60:\n            duration = timedelta(minutes=60)\n        case _:\n            raise ValueError(\n                \"Invalid duration value. Duration must be 5, 15, 30, or 60 minutes.\"\n            )\n    return cls(start=start, duration=duration)\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.DeliveryPeriod.to_pb","title":"to_pb","text":"<pre><code>to_pb() -&gt; DeliveryPeriod\n</code></pre> <p>Convert a DeliveryPeriod object to protobuf DeliveryPeriod.</p> RETURNS DESCRIPTION <code>DeliveryPeriod</code> <p>Protobuf message corresponding to the DeliveryPeriod object.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>def to_pb(self) -&gt; delivery_duration_pb2.DeliveryPeriod:\n    \"\"\"Convert a DeliveryPeriod object to protobuf DeliveryPeriod.\n\n    Returns:\n        Protobuf message corresponding to the DeliveryPeriod object.\n    \"\"\"\n    start = timestamp_pb2.Timestamp()\n    start.FromDatetime(self.start)\n    return delivery_duration_pb2.DeliveryPeriod(\n        start=start,\n        duration=self.duration.to_pb(),\n    )\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.EnergyMarketCodeType","title":"frequenz.client.electricity_trading.EnergyMarketCodeType","text":"<p>               Bases: <code>Enum</code></p> <p>Specifies the type of identification code used in the energy market.</p> <p>This is used for uniquely identifying various entities such as delivery areas, market participants, and grid components. This enumeration aims to offer compatibility across different jurisdictional standards.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>class EnergyMarketCodeType(enum.Enum):\n    \"\"\"\n    Specifies the type of identification code used in the energy market.\n\n    This is used for uniquely identifying various entities such as delivery areas, market\n    participants, and grid components. This enumeration aims to offer compatibility across\n    different jurisdictional standards.\n    \"\"\"\n\n    UNSPECIFIED = (\n        delivery_area_pb2.EnergyMarketCodeType.ENERGY_MARKET_CODE_TYPE_UNSPECIFIED\n    )\n    \"\"\"Unspecified type. This value is a placeholder and should not be used.\"\"\"\n\n    EUROPE_EIC = (\n        delivery_area_pb2.EnergyMarketCodeType.ENERGY_MARKET_CODE_TYPE_EUROPE_EIC\n    )\n    \"\"\"European Energy Identification Code Standard.\"\"\"\n\n    US_NERC = delivery_area_pb2.EnergyMarketCodeType.ENERGY_MARKET_CODE_TYPE_US_NERC\n    \"\"\"North American Electric Reliability Corporation identifiers.\"\"\"\n\n    @classmethod\n    def from_pb(\n        cls, energy_market_code_type: delivery_area_pb2.EnergyMarketCodeType.ValueType\n    ) -&gt; \"EnergyMarketCodeType\":\n        \"\"\"Convert a protobuf EnergyMarketCodeType value to EnergyMarketCodeType enum.\n\n        Args:\n            energy_market_code_type: Energy market code type to convert.\n\n        Returns:\n            Enum value corresponding to the protobuf message.\n        \"\"\"\n        if not any(e.value == energy_market_code_type for e in cls):\n            _logger.warning(\n                \"Unknown energy market code type %s. Returning UNSPECIFIED.\",\n                energy_market_code_type,\n            )\n            return cls.UNSPECIFIED\n\n        return cls(energy_market_code_type)\n\n    def to_pb(self) -&gt; delivery_area_pb2.EnergyMarketCodeType.ValueType:\n        \"\"\"Convert a EnergyMarketCodeType object to protobuf EnergyMarketCodeType.\n\n        Returns:\n            Protobuf message corresponding to the EnergyMarketCodeType object.\n        \"\"\"\n        return delivery_area_pb2.EnergyMarketCodeType.ValueType(self.value)\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.EnergyMarketCodeType-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.EnergyMarketCodeType.EUROPE_EIC","title":"EUROPE_EIC  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>EUROPE_EIC = ENERGY_MARKET_CODE_TYPE_EUROPE_EIC\n</code></pre> <p>European Energy Identification Code Standard.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.EnergyMarketCodeType.UNSPECIFIED","title":"UNSPECIFIED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>UNSPECIFIED = ENERGY_MARKET_CODE_TYPE_UNSPECIFIED\n</code></pre> <p>Unspecified type. This value is a placeholder and should not be used.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.EnergyMarketCodeType.US_NERC","title":"US_NERC  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>US_NERC = ENERGY_MARKET_CODE_TYPE_US_NERC\n</code></pre> <p>North American Electric Reliability Corporation identifiers.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.EnergyMarketCodeType-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.EnergyMarketCodeType.from_pb","title":"from_pb  <code>classmethod</code>","text":"<pre><code>from_pb(\n    energy_market_code_type: ValueType,\n) -&gt; \"EnergyMarketCodeType\"\n</code></pre> <p>Convert a protobuf EnergyMarketCodeType value to EnergyMarketCodeType enum.</p> PARAMETER DESCRIPTION <code>energy_market_code_type</code> <p>Energy market code type to convert.</p> <p> TYPE: <code>ValueType</code> </p> RETURNS DESCRIPTION <code>'EnergyMarketCodeType'</code> <p>Enum value corresponding to the protobuf message.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>@classmethod\ndef from_pb(\n    cls, energy_market_code_type: delivery_area_pb2.EnergyMarketCodeType.ValueType\n) -&gt; \"EnergyMarketCodeType\":\n    \"\"\"Convert a protobuf EnergyMarketCodeType value to EnergyMarketCodeType enum.\n\n    Args:\n        energy_market_code_type: Energy market code type to convert.\n\n    Returns:\n        Enum value corresponding to the protobuf message.\n    \"\"\"\n    if not any(e.value == energy_market_code_type for e in cls):\n        _logger.warning(\n            \"Unknown energy market code type %s. Returning UNSPECIFIED.\",\n            energy_market_code_type,\n        )\n        return cls.UNSPECIFIED\n\n    return cls(energy_market_code_type)\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.EnergyMarketCodeType.to_pb","title":"to_pb","text":"<pre><code>to_pb() -&gt; ValueType\n</code></pre> <p>Convert a EnergyMarketCodeType object to protobuf EnergyMarketCodeType.</p> RETURNS DESCRIPTION <code>ValueType</code> <p>Protobuf message corresponding to the EnergyMarketCodeType object.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>def to_pb(self) -&gt; delivery_area_pb2.EnergyMarketCodeType.ValueType:\n    \"\"\"Convert a EnergyMarketCodeType object to protobuf EnergyMarketCodeType.\n\n    Returns:\n        Protobuf message corresponding to the EnergyMarketCodeType object.\n    \"\"\"\n    return delivery_area_pb2.EnergyMarketCodeType.ValueType(self.value)\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.GridpoolOrderFilter","title":"frequenz.client.electricity_trading.GridpoolOrderFilter  <code>dataclass</code>","text":"<p>Parameters for filtering Gridpool orders.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>@dataclass(frozen=True)\nclass GridpoolOrderFilter:\n    \"\"\"Parameters for filtering Gridpool orders.\"\"\"\n\n    order_states: list[OrderState] | None = None\n    \"\"\"List of order states to filter for.\"\"\"\n\n    side: MarketSide | None = None\n    \"\"\"Market side to filter for.\"\"\"\n\n    delivery_period: DeliveryPeriod | None = None\n    \"\"\"Delivery period to filter for.\"\"\"\n\n    delivery_area: DeliveryArea | None = None\n    \"\"\"Delivery area to filter for.\"\"\"\n\n    tag: str | None = None\n    \"\"\"Tag associated with the orders to be filtered.\"\"\"\n\n    def __eq__(self, other: object) -&gt; bool:\n        \"\"\"\n        Check if two GridpoolOrderFilter objects are equal.\n\n        Args:\n            other: GridpoolOrderFilter object to compare with.\n\n        Returns:\n            True if the two GridpoolOrderFilter objects are equal, False otherwise.\n        \"\"\"\n        if not isinstance(other, GridpoolOrderFilter):\n            return NotImplemented\n        return (\n            self.order_states == other.order_states\n            and self.side == other.side\n            and self.delivery_period == other.delivery_period\n            and self.delivery_area == other.delivery_area\n            and self.tag == other.tag\n        )\n\n    def __hash__(self) -&gt; int:\n        \"\"\"\n        Create hash of the GridpoolOrderFilter object.\n\n        Returns:\n            Hash of the GridpoolOrderFilter object.\n        \"\"\"\n        return hash(\n            (\n                tuple(self.order_states) if self.order_states is not None else None,\n                self.side,\n                self.delivery_period,\n                self.delivery_area,\n                self.tag,\n            )\n        )\n\n    @classmethod\n    def from_pb(\n        cls, gridpool_order_filter: electricity_trading_pb2.GridpoolOrderFilter\n    ) -&gt; Self:\n        \"\"\"Convert a protobuf GridpoolOrderFilter to GridpoolOrderFilter object.\n\n        Args:\n            gridpool_order_filter: GridpoolOrderFilter to convert.\n\n        Returns:\n            GridpoolOrderFilter object corresponding to the protobuf message.\n        \"\"\"\n        return cls(\n            order_states=(\n                [OrderState.from_pb(state) for state in gridpool_order_filter.states]\n                if gridpool_order_filter.states\n                else None\n            ),\n            side=(\n                MarketSide.from_pb(gridpool_order_filter.side)\n                if gridpool_order_filter.HasField(\"side\")\n                else None\n            ),\n            delivery_period=(\n                DeliveryPeriod.from_pb(gridpool_order_filter.delivery_period)\n                if gridpool_order_filter.HasField(\"delivery_period\")\n                else None\n            ),\n            delivery_area=(\n                DeliveryArea.from_pb(gridpool_order_filter.delivery_area)\n                if gridpool_order_filter.HasField(\"delivery_area\")\n                else None\n            ),\n            tag=(\n                gridpool_order_filter.tag\n                if gridpool_order_filter.HasField(\"tag\")\n                else None\n            ),\n        )\n\n    def to_pb(self) -&gt; electricity_trading_pb2.GridpoolOrderFilter:\n        \"\"\"Convert a GridpoolOrderFilter object to protobuf GridpoolOrderFilter.\n\n        Returns:\n            Protobuf GridpoolOrderFilter corresponding to the object.\n        \"\"\"\n        return electricity_trading_pb2.GridpoolOrderFilter(\n            states=(\n                [\n                    electricity_trading_pb2.OrderState.ValueType(state.value)\n                    for state in self.order_states\n                ]\n                if self.order_states\n                else None\n            ),\n            side=(\n                electricity_trading_pb2.MarketSide.ValueType(self.side.value)\n                if self.side\n                else None\n            ),\n            delivery_period=(\n                self.delivery_period.to_pb() if self.delivery_period else None\n            ),\n            delivery_area=self.delivery_area.to_pb() if self.delivery_area else None,\n            tag=self.tag if self.tag else None,\n        )\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.GridpoolOrderFilter-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.GridpoolOrderFilter.delivery_area","title":"delivery_area  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>delivery_area: DeliveryArea | None = None\n</code></pre> <p>Delivery area to filter for.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.GridpoolOrderFilter.delivery_period","title":"delivery_period  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>delivery_period: DeliveryPeriod | None = None\n</code></pre> <p>Delivery period to filter for.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.GridpoolOrderFilter.order_states","title":"order_states  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>order_states: list[OrderState] | None = None\n</code></pre> <p>List of order states to filter for.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.GridpoolOrderFilter.side","title":"side  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>side: MarketSide | None = None\n</code></pre> <p>Market side to filter for.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.GridpoolOrderFilter.tag","title":"tag  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tag: str | None = None\n</code></pre> <p>Tag associated with the orders to be filtered.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.GridpoolOrderFilter-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.GridpoolOrderFilter.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: object) -&gt; bool\n</code></pre> <p>Check if two GridpoolOrderFilter objects are equal.</p> PARAMETER DESCRIPTION <code>other</code> <p>GridpoolOrderFilter object to compare with.</p> <p> TYPE: <code>object</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if the two GridpoolOrderFilter objects are equal, False otherwise.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>def __eq__(self, other: object) -&gt; bool:\n    \"\"\"\n    Check if two GridpoolOrderFilter objects are equal.\n\n    Args:\n        other: GridpoolOrderFilter object to compare with.\n\n    Returns:\n        True if the two GridpoolOrderFilter objects are equal, False otherwise.\n    \"\"\"\n    if not isinstance(other, GridpoolOrderFilter):\n        return NotImplemented\n    return (\n        self.order_states == other.order_states\n        and self.side == other.side\n        and self.delivery_period == other.delivery_period\n        and self.delivery_area == other.delivery_area\n        and self.tag == other.tag\n    )\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.GridpoolOrderFilter.__hash__","title":"__hash__","text":"<pre><code>__hash__() -&gt; int\n</code></pre> <p>Create hash of the GridpoolOrderFilter object.</p> RETURNS DESCRIPTION <code>int</code> <p>Hash of the GridpoolOrderFilter object.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>def __hash__(self) -&gt; int:\n    \"\"\"\n    Create hash of the GridpoolOrderFilter object.\n\n    Returns:\n        Hash of the GridpoolOrderFilter object.\n    \"\"\"\n    return hash(\n        (\n            tuple(self.order_states) if self.order_states is not None else None,\n            self.side,\n            self.delivery_period,\n            self.delivery_area,\n            self.tag,\n        )\n    )\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.GridpoolOrderFilter.from_pb","title":"from_pb  <code>classmethod</code>","text":"<pre><code>from_pb(gridpool_order_filter: GridpoolOrderFilter) -&gt; Self\n</code></pre> <p>Convert a protobuf GridpoolOrderFilter to GridpoolOrderFilter object.</p> PARAMETER DESCRIPTION <code>gridpool_order_filter</code> <p>GridpoolOrderFilter to convert.</p> <p> TYPE: <code>GridpoolOrderFilter</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>GridpoolOrderFilter object corresponding to the protobuf message.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>@classmethod\ndef from_pb(\n    cls, gridpool_order_filter: electricity_trading_pb2.GridpoolOrderFilter\n) -&gt; Self:\n    \"\"\"Convert a protobuf GridpoolOrderFilter to GridpoolOrderFilter object.\n\n    Args:\n        gridpool_order_filter: GridpoolOrderFilter to convert.\n\n    Returns:\n        GridpoolOrderFilter object corresponding to the protobuf message.\n    \"\"\"\n    return cls(\n        order_states=(\n            [OrderState.from_pb(state) for state in gridpool_order_filter.states]\n            if gridpool_order_filter.states\n            else None\n        ),\n        side=(\n            MarketSide.from_pb(gridpool_order_filter.side)\n            if gridpool_order_filter.HasField(\"side\")\n            else None\n        ),\n        delivery_period=(\n            DeliveryPeriod.from_pb(gridpool_order_filter.delivery_period)\n            if gridpool_order_filter.HasField(\"delivery_period\")\n            else None\n        ),\n        delivery_area=(\n            DeliveryArea.from_pb(gridpool_order_filter.delivery_area)\n            if gridpool_order_filter.HasField(\"delivery_area\")\n            else None\n        ),\n        tag=(\n            gridpool_order_filter.tag\n            if gridpool_order_filter.HasField(\"tag\")\n            else None\n        ),\n    )\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.GridpoolOrderFilter.to_pb","title":"to_pb","text":"<pre><code>to_pb() -&gt; GridpoolOrderFilter\n</code></pre> <p>Convert a GridpoolOrderFilter object to protobuf GridpoolOrderFilter.</p> RETURNS DESCRIPTION <code>GridpoolOrderFilter</code> <p>Protobuf GridpoolOrderFilter corresponding to the object.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>def to_pb(self) -&gt; electricity_trading_pb2.GridpoolOrderFilter:\n    \"\"\"Convert a GridpoolOrderFilter object to protobuf GridpoolOrderFilter.\n\n    Returns:\n        Protobuf GridpoolOrderFilter corresponding to the object.\n    \"\"\"\n    return electricity_trading_pb2.GridpoolOrderFilter(\n        states=(\n            [\n                electricity_trading_pb2.OrderState.ValueType(state.value)\n                for state in self.order_states\n            ]\n            if self.order_states\n            else None\n        ),\n        side=(\n            electricity_trading_pb2.MarketSide.ValueType(self.side.value)\n            if self.side\n            else None\n        ),\n        delivery_period=(\n            self.delivery_period.to_pb() if self.delivery_period else None\n        ),\n        delivery_area=self.delivery_area.to_pb() if self.delivery_area else None,\n        tag=self.tag if self.tag else None,\n    )\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.GridpoolTradeFilter","title":"frequenz.client.electricity_trading.GridpoolTradeFilter  <code>dataclass</code>","text":"<p>Parameters for filtering Gridpool trades.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>@dataclass(frozen=True)\nclass GridpoolTradeFilter:\n    \"\"\"Parameters for filtering Gridpool trades.\"\"\"\n\n    trade_states: list[TradeState] | None = None\n    \"\"\"List of trade states to filter for.\"\"\"\n\n    trade_ids: list[int] | None = None\n    \"\"\"List of trade ids to filter for.\"\"\"\n\n    side: MarketSide | None = None\n    \"\"\"Market side to filter for.\"\"\"\n\n    delivery_period: DeliveryPeriod | None = None\n    \"\"\"Delivery period to filter for.\"\"\"\n\n    delivery_area: DeliveryArea | None = None\n    \"\"\"Delivery area to filter for.\"\"\"\n\n    def __eq__(self, other: object) -&gt; bool:\n        \"\"\"\n        Check if two GridpoolTradeFilter objects are equal.\n\n        Args:\n            other: GridpoolTradeFilter object to compare with.\n\n        Returns:\n            True if the two GridpoolTradeFilter objects are equal, False otherwise.\n        \"\"\"\n        if not isinstance(other, GridpoolTradeFilter):\n            return NotImplemented\n        return (\n            self.trade_states == other.trade_states\n            and self.trade_ids == other.trade_ids\n            and self.side == other.side\n            and self.delivery_period == other.delivery_period\n            and self.delivery_area == other.delivery_area\n        )\n\n    def __hash__(self) -&gt; int:\n        \"\"\"\n        Create hash of the GridpoolTradeFilter object.\n\n        Returns:\n            Hash of the GridpoolTradeFilter object.\n        \"\"\"\n        return hash(\n            (\n                tuple(self.trade_states) if self.trade_states is not None else None,\n                tuple(self.trade_ids) if self.trade_ids is not None else None,\n                self.side,\n                self.delivery_period,\n                self.delivery_area,\n            )\n        )\n\n    @classmethod\n    def from_pb(\n        cls, gridpool_trade_filter: electricity_trading_pb2.GridpoolTradeFilter\n    ) -&gt; \"GridpoolTradeFilter\":\n        \"\"\"Convert a protobuf GridpoolTradeFilter to GridpoolTradeFilter object.\n\n        Args:\n            gridpool_trade_filter: GridpoolTradeFilter to convert.\n\n        Returns:\n            GridpoolTradeFilter object corresponding to the protobuf message.\n        \"\"\"\n        return cls(\n            trade_states=(\n                [TradeState.from_pb(state) for state in gridpool_trade_filter.states]\n                if gridpool_trade_filter.states\n                else None\n            ),\n            trade_ids=(\n                list(gridpool_trade_filter.trade_ids)\n                if gridpool_trade_filter.trade_ids\n                else None\n            ),\n            side=(\n                MarketSide.from_pb(gridpool_trade_filter.side)\n                if gridpool_trade_filter.HasField(\"side\")\n                else None\n            ),\n            delivery_period=(\n                DeliveryPeriod.from_pb(gridpool_trade_filter.delivery_period)\n                if gridpool_trade_filter.HasField(\"delivery_period\")\n                else None\n            ),\n            delivery_area=(\n                DeliveryArea.from_pb(gridpool_trade_filter.delivery_area)\n                if gridpool_trade_filter.HasField(\"delivery_area\")\n                else None\n            ),\n        )\n\n    def to_pb(self) -&gt; electricity_trading_pb2.GridpoolTradeFilter:\n        \"\"\"\n        Convert a GridpoolTradeFilter object to protobuf GridpoolTradeFilter.\n\n        Returns:\n            Protobuf GridpoolTradeFilter corresponding to the object.\n        \"\"\"\n        return electricity_trading_pb2.GridpoolTradeFilter(\n            states=(\n                [TradeState.to_pb(state) for state in self.trade_states]\n                if self.trade_states\n                else None\n            ),\n            trade_ids=self.trade_ids if self.trade_ids else None,\n            side=MarketSide.to_pb(self.side) if self.side else None,\n            delivery_period=(\n                self.delivery_period.to_pb() if self.delivery_period else None\n            ),\n            delivery_area=self.delivery_area.to_pb() if self.delivery_area else None,\n        )\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.GridpoolTradeFilter-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.GridpoolTradeFilter.delivery_area","title":"delivery_area  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>delivery_area: DeliveryArea | None = None\n</code></pre> <p>Delivery area to filter for.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.GridpoolTradeFilter.delivery_period","title":"delivery_period  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>delivery_period: DeliveryPeriod | None = None\n</code></pre> <p>Delivery period to filter for.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.GridpoolTradeFilter.side","title":"side  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>side: MarketSide | None = None\n</code></pre> <p>Market side to filter for.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.GridpoolTradeFilter.trade_ids","title":"trade_ids  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>trade_ids: list[int] | None = None\n</code></pre> <p>List of trade ids to filter for.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.GridpoolTradeFilter.trade_states","title":"trade_states  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>trade_states: list[TradeState] | None = None\n</code></pre> <p>List of trade states to filter for.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.GridpoolTradeFilter-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.GridpoolTradeFilter.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: object) -&gt; bool\n</code></pre> <p>Check if two GridpoolTradeFilter objects are equal.</p> PARAMETER DESCRIPTION <code>other</code> <p>GridpoolTradeFilter object to compare with.</p> <p> TYPE: <code>object</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if the two GridpoolTradeFilter objects are equal, False otherwise.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>def __eq__(self, other: object) -&gt; bool:\n    \"\"\"\n    Check if two GridpoolTradeFilter objects are equal.\n\n    Args:\n        other: GridpoolTradeFilter object to compare with.\n\n    Returns:\n        True if the two GridpoolTradeFilter objects are equal, False otherwise.\n    \"\"\"\n    if not isinstance(other, GridpoolTradeFilter):\n        return NotImplemented\n    return (\n        self.trade_states == other.trade_states\n        and self.trade_ids == other.trade_ids\n        and self.side == other.side\n        and self.delivery_period == other.delivery_period\n        and self.delivery_area == other.delivery_area\n    )\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.GridpoolTradeFilter.__hash__","title":"__hash__","text":"<pre><code>__hash__() -&gt; int\n</code></pre> <p>Create hash of the GridpoolTradeFilter object.</p> RETURNS DESCRIPTION <code>int</code> <p>Hash of the GridpoolTradeFilter object.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>def __hash__(self) -&gt; int:\n    \"\"\"\n    Create hash of the GridpoolTradeFilter object.\n\n    Returns:\n        Hash of the GridpoolTradeFilter object.\n    \"\"\"\n    return hash(\n        (\n            tuple(self.trade_states) if self.trade_states is not None else None,\n            tuple(self.trade_ids) if self.trade_ids is not None else None,\n            self.side,\n            self.delivery_period,\n            self.delivery_area,\n        )\n    )\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.GridpoolTradeFilter.from_pb","title":"from_pb  <code>classmethod</code>","text":"<pre><code>from_pb(\n    gridpool_trade_filter: GridpoolTradeFilter,\n) -&gt; \"GridpoolTradeFilter\"\n</code></pre> <p>Convert a protobuf GridpoolTradeFilter to GridpoolTradeFilter object.</p> PARAMETER DESCRIPTION <code>gridpool_trade_filter</code> <p>GridpoolTradeFilter to convert.</p> <p> TYPE: <code>GridpoolTradeFilter</code> </p> RETURNS DESCRIPTION <code>'GridpoolTradeFilter'</code> <p>GridpoolTradeFilter object corresponding to the protobuf message.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>@classmethod\ndef from_pb(\n    cls, gridpool_trade_filter: electricity_trading_pb2.GridpoolTradeFilter\n) -&gt; \"GridpoolTradeFilter\":\n    \"\"\"Convert a protobuf GridpoolTradeFilter to GridpoolTradeFilter object.\n\n    Args:\n        gridpool_trade_filter: GridpoolTradeFilter to convert.\n\n    Returns:\n        GridpoolTradeFilter object corresponding to the protobuf message.\n    \"\"\"\n    return cls(\n        trade_states=(\n            [TradeState.from_pb(state) for state in gridpool_trade_filter.states]\n            if gridpool_trade_filter.states\n            else None\n        ),\n        trade_ids=(\n            list(gridpool_trade_filter.trade_ids)\n            if gridpool_trade_filter.trade_ids\n            else None\n        ),\n        side=(\n            MarketSide.from_pb(gridpool_trade_filter.side)\n            if gridpool_trade_filter.HasField(\"side\")\n            else None\n        ),\n        delivery_period=(\n            DeliveryPeriod.from_pb(gridpool_trade_filter.delivery_period)\n            if gridpool_trade_filter.HasField(\"delivery_period\")\n            else None\n        ),\n        delivery_area=(\n            DeliveryArea.from_pb(gridpool_trade_filter.delivery_area)\n            if gridpool_trade_filter.HasField(\"delivery_area\")\n            else None\n        ),\n    )\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.GridpoolTradeFilter.to_pb","title":"to_pb","text":"<pre><code>to_pb() -&gt; GridpoolTradeFilter\n</code></pre> <p>Convert a GridpoolTradeFilter object to protobuf GridpoolTradeFilter.</p> RETURNS DESCRIPTION <code>GridpoolTradeFilter</code> <p>Protobuf GridpoolTradeFilter corresponding to the object.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>def to_pb(self) -&gt; electricity_trading_pb2.GridpoolTradeFilter:\n    \"\"\"\n    Convert a GridpoolTradeFilter object to protobuf GridpoolTradeFilter.\n\n    Returns:\n        Protobuf GridpoolTradeFilter corresponding to the object.\n    \"\"\"\n    return electricity_trading_pb2.GridpoolTradeFilter(\n        states=(\n            [TradeState.to_pb(state) for state in self.trade_states]\n            if self.trade_states\n            else None\n        ),\n        trade_ids=self.trade_ids if self.trade_ids else None,\n        side=MarketSide.to_pb(self.side) if self.side else None,\n        delivery_period=(\n            self.delivery_period.to_pb() if self.delivery_period else None\n        ),\n        delivery_area=self.delivery_area.to_pb() if self.delivery_area else None,\n    )\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.MarketActor","title":"frequenz.client.electricity_trading.MarketActor","text":"<p>               Bases: <code>Enum</code></p> <p>Actors responsible for an order state change.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>class MarketActor(enum.Enum):\n    \"\"\"Actors responsible for an order state change.\"\"\"\n\n    UNSPECIFIED = (\n        electricity_trading_pb2.OrderDetail.StateDetail.MarketActor.MARKET_ACTOR_UNSPECIFIED\n    )\n    \"\"\"The actor responsible for the state change has not been specified.\"\"\"\n\n    USER = electricity_trading_pb2.OrderDetail.StateDetail.MarketActor.MARKET_ACTOR_USER\n    \"\"\"The user was the actor.\"\"\"\n\n    MARKET_OPERATOR = (\n        electricity_trading_pb2.OrderDetail.StateDetail.MarketActor.MARKET_ACTOR_MARKET_OPERATOR\n    )\n    \"\"\"The market operator was the actor.\"\"\"\n\n    SYSTEM = (\n        electricity_trading_pb2.OrderDetail.StateDetail.MarketActor.MARKET_ACTOR_SYSTEM\n    )\n    \"\"\"The system was the actor.\"\"\"\n\n    @classmethod\n    def from_pb(\n        cls,\n        market_actor: electricity_trading_pb2.OrderDetail.StateDetail.MarketActor.ValueType,\n    ) -&gt; \"MarketActor\":\n        \"\"\"Convert a protobuf MarketActor value to MarketActor enum.\n\n        Args:\n            market_actor: Market actor to convert.\n\n        Returns:\n            Enum value corresponding to the protobuf message.\n        \"\"\"\n        if not any(e.value == market_actor for e in cls):\n            _logger.warning(\n                \"Unknown market actor %s. Returning UNSPECIFIED.\", market_actor\n            )\n            return cls.UNSPECIFIED\n\n        return cls(market_actor)\n\n    def to_pb(\n        self,\n    ) -&gt; electricity_trading_pb2.OrderDetail.StateDetail.MarketActor.ValueType:\n        \"\"\"Convert a MarketActor enum to protobuf MarketActor value.\n\n        Returns:\n            Protobuf message corresponding to the MarketActor enum.\n        \"\"\"\n        return self.value\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.MarketActor-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.MarketActor.MARKET_OPERATOR","title":"MARKET_OPERATOR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MARKET_OPERATOR = MARKET_ACTOR_MARKET_OPERATOR\n</code></pre> <p>The market operator was the actor.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.MarketActor.SYSTEM","title":"SYSTEM  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SYSTEM = MARKET_ACTOR_SYSTEM\n</code></pre> <p>The system was the actor.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.MarketActor.UNSPECIFIED","title":"UNSPECIFIED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>UNSPECIFIED = MARKET_ACTOR_UNSPECIFIED\n</code></pre> <p>The actor responsible for the state change has not been specified.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.MarketActor.USER","title":"USER  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>USER = MARKET_ACTOR_USER\n</code></pre> <p>The user was the actor.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.MarketActor-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.MarketActor.from_pb","title":"from_pb  <code>classmethod</code>","text":"<pre><code>from_pb(market_actor: ValueType) -&gt; 'MarketActor'\n</code></pre> <p>Convert a protobuf MarketActor value to MarketActor enum.</p> PARAMETER DESCRIPTION <code>market_actor</code> <p>Market actor to convert.</p> <p> TYPE: <code>ValueType</code> </p> RETURNS DESCRIPTION <code>'MarketActor'</code> <p>Enum value corresponding to the protobuf message.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>@classmethod\ndef from_pb(\n    cls,\n    market_actor: electricity_trading_pb2.OrderDetail.StateDetail.MarketActor.ValueType,\n) -&gt; \"MarketActor\":\n    \"\"\"Convert a protobuf MarketActor value to MarketActor enum.\n\n    Args:\n        market_actor: Market actor to convert.\n\n    Returns:\n        Enum value corresponding to the protobuf message.\n    \"\"\"\n    if not any(e.value == market_actor for e in cls):\n        _logger.warning(\n            \"Unknown market actor %s. Returning UNSPECIFIED.\", market_actor\n        )\n        return cls.UNSPECIFIED\n\n    return cls(market_actor)\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.MarketActor.to_pb","title":"to_pb","text":"<pre><code>to_pb() -&gt; ValueType\n</code></pre> <p>Convert a MarketActor enum to protobuf MarketActor value.</p> RETURNS DESCRIPTION <code>ValueType</code> <p>Protobuf message corresponding to the MarketActor enum.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>def to_pb(\n    self,\n) -&gt; electricity_trading_pb2.OrderDetail.StateDetail.MarketActor.ValueType:\n    \"\"\"Convert a MarketActor enum to protobuf MarketActor value.\n\n    Returns:\n        Protobuf message corresponding to the MarketActor enum.\n    \"\"\"\n    return self.value\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.MarketSide","title":"frequenz.client.electricity_trading.MarketSide","text":"<p>               Bases: <code>Enum</code></p> <p>Which side of the market the order is on, either buying or selling.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>class MarketSide(enum.Enum):\n    \"\"\"Which side of the market the order is on, either buying or selling.\"\"\"\n\n    UNSPECIFIED = electricity_trading_pb2.MarketSide.MARKET_SIDE_UNSPECIFIED\n    \"\"\"The side of the market has not been set.\"\"\"\n\n    BUY = electricity_trading_pb2.MarketSide.MARKET_SIDE_BUY\n    \"\"\"Order to purchase electricity, referred to as a 'bid' in the order book.\"\"\"\n\n    SELL = electricity_trading_pb2.MarketSide.MARKET_SIDE_SELL\n    \"\"\"Order to sell electricity, referred to as an 'ask' or 'offer' in the order book.\"\"\"\n\n    @classmethod\n    def from_pb(\n        cls, market_side: electricity_trading_pb2.MarketSide.ValueType\n    ) -&gt; \"MarketSide\":\n        \"\"\"Convert a protobuf MarketSide value to MarketSide enum.\n\n        Args:\n            market_side: Market side to convert.\n\n        Returns:\n            Enum value corresponding to the protobuf message.\n        \"\"\"\n        if not any(e.value == market_side for e in cls):\n            _logger.warning(\n                \"Unknown market side %s. Returning UNSPECIFIED.\", market_side\n            )\n            return cls.UNSPECIFIED\n\n        return cls(market_side)\n\n    def to_pb(self) -&gt; electricity_trading_pb2.MarketSide.ValueType:\n        \"\"\"Convert a MarketSide enum to protobuf MarketSide value.\n\n        Returns:\n            Protobuf message corresponding to the MarketSide enum.\n        \"\"\"\n        return self.value\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.MarketSide-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.MarketSide.BUY","title":"BUY  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>BUY = MARKET_SIDE_BUY\n</code></pre> <p>Order to purchase electricity, referred to as a 'bid' in the order book.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.MarketSide.SELL","title":"SELL  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SELL = MARKET_SIDE_SELL\n</code></pre> <p>Order to sell electricity, referred to as an 'ask' or 'offer' in the order book.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.MarketSide.UNSPECIFIED","title":"UNSPECIFIED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>UNSPECIFIED = MARKET_SIDE_UNSPECIFIED\n</code></pre> <p>The side of the market has not been set.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.MarketSide-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.MarketSide.from_pb","title":"from_pb  <code>classmethod</code>","text":"<pre><code>from_pb(market_side: ValueType) -&gt; 'MarketSide'\n</code></pre> <p>Convert a protobuf MarketSide value to MarketSide enum.</p> PARAMETER DESCRIPTION <code>market_side</code> <p>Market side to convert.</p> <p> TYPE: <code>ValueType</code> </p> RETURNS DESCRIPTION <code>'MarketSide'</code> <p>Enum value corresponding to the protobuf message.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>@classmethod\ndef from_pb(\n    cls, market_side: electricity_trading_pb2.MarketSide.ValueType\n) -&gt; \"MarketSide\":\n    \"\"\"Convert a protobuf MarketSide value to MarketSide enum.\n\n    Args:\n        market_side: Market side to convert.\n\n    Returns:\n        Enum value corresponding to the protobuf message.\n    \"\"\"\n    if not any(e.value == market_side for e in cls):\n        _logger.warning(\n            \"Unknown market side %s. Returning UNSPECIFIED.\", market_side\n        )\n        return cls.UNSPECIFIED\n\n    return cls(market_side)\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.MarketSide.to_pb","title":"to_pb","text":"<pre><code>to_pb() -&gt; ValueType\n</code></pre> <p>Convert a MarketSide enum to protobuf MarketSide value.</p> RETURNS DESCRIPTION <code>ValueType</code> <p>Protobuf message corresponding to the MarketSide enum.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>def to_pb(self) -&gt; electricity_trading_pb2.MarketSide.ValueType:\n    \"\"\"Convert a MarketSide enum to protobuf MarketSide value.\n\n    Returns:\n        Protobuf message corresponding to the MarketSide enum.\n    \"\"\"\n    return self.value\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Order","title":"frequenz.client.electricity_trading.Order  <code>dataclass</code>","text":"<p>Represents an order in the electricity market.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>@dataclass()\nclass Order:  # pylint: disable=too-many-instance-attributes\n    \"\"\"Represents an order in the electricity market.\"\"\"\n\n    delivery_area: DeliveryArea\n    \"\"\"The delivery area where the contract is to be delivered.\"\"\"\n\n    delivery_period: DeliveryPeriod\n    \"\"\"The delivery period for the contract.\"\"\"\n\n    type: OrderType\n    \"\"\"The type of order.\"\"\"\n\n    side: MarketSide\n    \"\"\"Indicates if the order is on the Buy or Sell side of the market.\"\"\"\n\n    price: Price\n    \"\"\"The limit price at which the contract is to be traded.\"\"\"\n\n    quantity: Power\n    \"\"\"The quantity of the contract being traded.\"\"\"\n\n    stop_price: Price | None = None\n    \"\"\"Applicable for STOP_LIMIT orders. The stop price that triggers the limit order.\"\"\"\n\n    peak_price_delta: Price | None = None\n    \"\"\"Applicable for ICEBERG orders. The price difference between the peak price and\n    the limit price.\"\"\"\n\n    display_quantity: Power | None = None\n    \"\"\"Applicable for ICEBERG orders. The quantity of the order to be displayed in the order\n    book.\"\"\"\n\n    execution_option: OrderExecutionOption | None = None\n    \"\"\"Order execution options such as All or None, Fill or Kill, etc.\"\"\"\n\n    valid_until: datetime | None = None\n    \"\"\"UTC timestamp defining the time after which the order should be cancelled if not filled.\"\"\"\n\n    payload: dict[str, struct_pb2.Value] | None = None\n    \"\"\"User-defined payload individual to a specific order. This can be any data that needs to be\n    associated with the order.\"\"\"\n\n    tag: str | None = None\n    \"\"\"User-defined tag to group related orders.\"\"\"\n\n    def __post_init__(self) -&gt; None:\n        \"\"\"Post initialization checks to ensure that all datetimes are UTC.\"\"\"\n        if self.valid_until is not None:\n            if self.valid_until.tzinfo is None:\n                raise ValueError(\"Valid until must be a UTC datetime.\")\n            if self.valid_until.tzinfo != timezone.utc:\n                _logger.warning(\"Valid until is not a UTC datetime. Converting to UTC.\")\n                self.valid_until = self.valid_until.astimezone(timezone.utc)\n\n    @classmethod\n    def from_pb(cls, order: electricity_trading_pb2.Order) -&gt; Self:\n        \"\"\"Convert a protobuf Order to Order object.\n\n        Args:\n            order: Order to convert.\n\n        Returns:\n            Order object corresponding to the protobuf message.\n        \"\"\"\n        return cls(\n            delivery_area=DeliveryArea.from_pb(order.delivery_area),\n            delivery_period=DeliveryPeriod.from_pb(order.delivery_period),\n            type=OrderType.from_pb(order.type),\n            side=MarketSide.from_pb(order.side),\n            price=Price.from_pb(order.price),\n            quantity=Power.from_pb(order.quantity),\n            stop_price=(\n                Price.from_pb(order.stop_price)\n                if order.HasField(\"stop_price\")\n                else None\n            ),\n            peak_price_delta=(\n                Price.from_pb(order.peak_price_delta)\n                if order.HasField(\"peak_price_delta\")\n                else None\n            ),\n            display_quantity=(\n                Power.from_pb(order.display_quantity)\n                if order.HasField(\"display_quantity\")\n                else None\n            ),\n            execution_option=(\n                OrderExecutionOption.from_pb(order.execution_option)\n                if order.HasField(\"execution_option\")\n                else None\n            ),\n            valid_until=(\n                order.valid_until.ToDatetime(tzinfo=timezone.utc)\n                if order.HasField(\"valid_until\")\n                else None\n            ),\n            payload=json_format.MessageToDict(order.payload) if order.payload else None,\n            tag=order.tag if order.tag else None,\n        )\n\n    def to_pb(self) -&gt; electricity_trading_pb2.Order:\n        \"\"\"\n        Convert an Order object to protobuf Order.\n\n        Returns:\n            Protobuf message corresponding to the Order object.\n        \"\"\"\n        if self.valid_until:\n            valid_until = timestamp_pb2.Timestamp()\n            valid_until.FromDatetime(self.valid_until)\n        else:\n            valid_until = None\n        return electricity_trading_pb2.Order(\n            delivery_area=self.delivery_area.to_pb(),\n            delivery_period=self.delivery_period.to_pb(),\n            type=electricity_trading_pb2.OrderType.ValueType(self.type.value),\n            side=electricity_trading_pb2.MarketSide.ValueType(self.side.value),\n            price=self.price.to_pb(),\n            quantity=self.quantity.to_pb(),\n            stop_price=self.stop_price.to_pb() if self.stop_price else None,\n            peak_price_delta=(\n                self.peak_price_delta.to_pb() if self.peak_price_delta else None\n            ),\n            display_quantity=(\n                self.display_quantity.to_pb() if self.display_quantity else None\n            ),\n            execution_option=(\n                electricity_trading_pb2.OrderExecutionOption.ValueType(\n                    self.execution_option.value\n                )\n                if self.execution_option\n                else None\n            ),\n            valid_until=valid_until,\n            payload=struct_pb2.Struct(fields=self.payload) if self.payload else None,\n            tag=self.tag if self.tag else None,\n        )\n\n    def __eq__(self, other: object) -&gt; bool:\n        \"\"\"\n        Check if two orders are equal.\n\n        Args:\n            other: The other order to compare to.\n\n        Returns:\n            True if the orders are equal, False otherwise.\n        \"\"\"\n        if not isinstance(other, Order):\n            return NotImplemented\n        return (\n            self.delivery_area == other.delivery_area\n            and self.delivery_period.start == other.delivery_period.start\n            and self.delivery_period.duration == other.delivery_period.duration\n            and self.type == other.type\n            and self.side == other.side\n            and self.price == other.price\n            and self.quantity == other.quantity\n            and self.stop_price == other.stop_price\n            and self.peak_price_delta == other.peak_price_delta\n            and self.display_quantity == other.display_quantity\n            and (\n                self.execution_option == other.execution_option\n                or (\n                    self.execution_option is None\n                    and other.execution_option == OrderExecutionOption.UNSPECIFIED\n                )\n                or (\n                    self.execution_option == OrderExecutionOption.UNSPECIFIED\n                    and other.execution_option is None\n                )\n            )\n            and self.valid_until == other.valid_until\n            and self.payload == other.payload\n            and self.tag == other.tag\n        )\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Order-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Order.delivery_area","title":"delivery_area  <code>instance-attribute</code>","text":"<pre><code>delivery_area: DeliveryArea\n</code></pre> <p>The delivery area where the contract is to be delivered.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Order.delivery_period","title":"delivery_period  <code>instance-attribute</code>","text":"<pre><code>delivery_period: DeliveryPeriod\n</code></pre> <p>The delivery period for the contract.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Order.display_quantity","title":"display_quantity  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>display_quantity: Power | None = None\n</code></pre> <p>Applicable for ICEBERG orders. The quantity of the order to be displayed in the order book.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Order.execution_option","title":"execution_option  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>execution_option: OrderExecutionOption | None = None\n</code></pre> <p>Order execution options such as All or None, Fill or Kill, etc.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Order.payload","title":"payload  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>payload: dict[str, Value] | None = None\n</code></pre> <p>User-defined payload individual to a specific order. This can be any data that needs to be associated with the order.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Order.peak_price_delta","title":"peak_price_delta  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>peak_price_delta: Price | None = None\n</code></pre> <p>Applicable for ICEBERG orders. The price difference between the peak price and the limit price.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Order.price","title":"price  <code>instance-attribute</code>","text":"<pre><code>price: Price\n</code></pre> <p>The limit price at which the contract is to be traded.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Order.quantity","title":"quantity  <code>instance-attribute</code>","text":"<pre><code>quantity: Power\n</code></pre> <p>The quantity of the contract being traded.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Order.side","title":"side  <code>instance-attribute</code>","text":"<pre><code>side: MarketSide\n</code></pre> <p>Indicates if the order is on the Buy or Sell side of the market.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Order.stop_price","title":"stop_price  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>stop_price: Price | None = None\n</code></pre> <p>Applicable for STOP_LIMIT orders. The stop price that triggers the limit order.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Order.tag","title":"tag  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tag: str | None = None\n</code></pre> <p>User-defined tag to group related orders.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Order.type","title":"type  <code>instance-attribute</code>","text":"<pre><code>type: OrderType\n</code></pre> <p>The type of order.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Order.valid_until","title":"valid_until  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>valid_until: datetime | None = None\n</code></pre> <p>UTC timestamp defining the time after which the order should be cancelled if not filled.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Order-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Order.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: object) -&gt; bool\n</code></pre> <p>Check if two orders are equal.</p> PARAMETER DESCRIPTION <code>other</code> <p>The other order to compare to.</p> <p> TYPE: <code>object</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if the orders are equal, False otherwise.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>def __eq__(self, other: object) -&gt; bool:\n    \"\"\"\n    Check if two orders are equal.\n\n    Args:\n        other: The other order to compare to.\n\n    Returns:\n        True if the orders are equal, False otherwise.\n    \"\"\"\n    if not isinstance(other, Order):\n        return NotImplemented\n    return (\n        self.delivery_area == other.delivery_area\n        and self.delivery_period.start == other.delivery_period.start\n        and self.delivery_period.duration == other.delivery_period.duration\n        and self.type == other.type\n        and self.side == other.side\n        and self.price == other.price\n        and self.quantity == other.quantity\n        and self.stop_price == other.stop_price\n        and self.peak_price_delta == other.peak_price_delta\n        and self.display_quantity == other.display_quantity\n        and (\n            self.execution_option == other.execution_option\n            or (\n                self.execution_option is None\n                and other.execution_option == OrderExecutionOption.UNSPECIFIED\n            )\n            or (\n                self.execution_option == OrderExecutionOption.UNSPECIFIED\n                and other.execution_option is None\n            )\n        )\n        and self.valid_until == other.valid_until\n        and self.payload == other.payload\n        and self.tag == other.tag\n    )\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Order.__post_init__","title":"__post_init__","text":"<pre><code>__post_init__() -&gt; None\n</code></pre> <p>Post initialization checks to ensure that all datetimes are UTC.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>def __post_init__(self) -&gt; None:\n    \"\"\"Post initialization checks to ensure that all datetimes are UTC.\"\"\"\n    if self.valid_until is not None:\n        if self.valid_until.tzinfo is None:\n            raise ValueError(\"Valid until must be a UTC datetime.\")\n        if self.valid_until.tzinfo != timezone.utc:\n            _logger.warning(\"Valid until is not a UTC datetime. Converting to UTC.\")\n            self.valid_until = self.valid_until.astimezone(timezone.utc)\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Order.from_pb","title":"from_pb  <code>classmethod</code>","text":"<pre><code>from_pb(order: Order) -&gt; Self\n</code></pre> <p>Convert a protobuf Order to Order object.</p> PARAMETER DESCRIPTION <code>order</code> <p>Order to convert.</p> <p> TYPE: <code>Order</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>Order object corresponding to the protobuf message.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>@classmethod\ndef from_pb(cls, order: electricity_trading_pb2.Order) -&gt; Self:\n    \"\"\"Convert a protobuf Order to Order object.\n\n    Args:\n        order: Order to convert.\n\n    Returns:\n        Order object corresponding to the protobuf message.\n    \"\"\"\n    return cls(\n        delivery_area=DeliveryArea.from_pb(order.delivery_area),\n        delivery_period=DeliveryPeriod.from_pb(order.delivery_period),\n        type=OrderType.from_pb(order.type),\n        side=MarketSide.from_pb(order.side),\n        price=Price.from_pb(order.price),\n        quantity=Power.from_pb(order.quantity),\n        stop_price=(\n            Price.from_pb(order.stop_price)\n            if order.HasField(\"stop_price\")\n            else None\n        ),\n        peak_price_delta=(\n            Price.from_pb(order.peak_price_delta)\n            if order.HasField(\"peak_price_delta\")\n            else None\n        ),\n        display_quantity=(\n            Power.from_pb(order.display_quantity)\n            if order.HasField(\"display_quantity\")\n            else None\n        ),\n        execution_option=(\n            OrderExecutionOption.from_pb(order.execution_option)\n            if order.HasField(\"execution_option\")\n            else None\n        ),\n        valid_until=(\n            order.valid_until.ToDatetime(tzinfo=timezone.utc)\n            if order.HasField(\"valid_until\")\n            else None\n        ),\n        payload=json_format.MessageToDict(order.payload) if order.payload else None,\n        tag=order.tag if order.tag else None,\n    )\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Order.to_pb","title":"to_pb","text":"<pre><code>to_pb() -&gt; Order\n</code></pre> <p>Convert an Order object to protobuf Order.</p> RETURNS DESCRIPTION <code>Order</code> <p>Protobuf message corresponding to the Order object.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>def to_pb(self) -&gt; electricity_trading_pb2.Order:\n    \"\"\"\n    Convert an Order object to protobuf Order.\n\n    Returns:\n        Protobuf message corresponding to the Order object.\n    \"\"\"\n    if self.valid_until:\n        valid_until = timestamp_pb2.Timestamp()\n        valid_until.FromDatetime(self.valid_until)\n    else:\n        valid_until = None\n    return electricity_trading_pb2.Order(\n        delivery_area=self.delivery_area.to_pb(),\n        delivery_period=self.delivery_period.to_pb(),\n        type=electricity_trading_pb2.OrderType.ValueType(self.type.value),\n        side=electricity_trading_pb2.MarketSide.ValueType(self.side.value),\n        price=self.price.to_pb(),\n        quantity=self.quantity.to_pb(),\n        stop_price=self.stop_price.to_pb() if self.stop_price else None,\n        peak_price_delta=(\n            self.peak_price_delta.to_pb() if self.peak_price_delta else None\n        ),\n        display_quantity=(\n            self.display_quantity.to_pb() if self.display_quantity else None\n        ),\n        execution_option=(\n            electricity_trading_pb2.OrderExecutionOption.ValueType(\n                self.execution_option.value\n            )\n            if self.execution_option\n            else None\n        ),\n        valid_until=valid_until,\n        payload=struct_pb2.Struct(fields=self.payload) if self.payload else None,\n        tag=self.tag if self.tag else None,\n    )\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderDetail","title":"frequenz.client.electricity_trading.OrderDetail  <code>dataclass</code>","text":"<p>Represents an order with full details, including its ID, state, and associated UTC timestamps.</p> ATTRIBUTE DESCRIPTION <code>order_id</code> <p>Unique identifier of the order.</p> <p> TYPE: <code>int</code> </p> <code>order</code> <p>The details of the order.</p> <p> TYPE: <code>Order</code> </p> <code>state_detail</code> <p>Details of the order's current state.</p> <p> TYPE: <code>StateDetail</code> </p> <code>open_quantity</code> <p>Remaining open quantity for this order.</p> <p> TYPE: <code>Power</code> </p> <code>filled_quantity</code> <p>Filled quantity for this order.</p> <p> TYPE: <code>Power</code> </p> <code>create_time</code> <p>UTC Timestamp when the order was created.</p> <p> TYPE: <code>datetime</code> </p> <code>modification_time</code> <p>UTC Timestamp of the last update to the order.</p> <p> TYPE: <code>datetime</code> </p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>@dataclass()\nclass OrderDetail:\n    \"\"\"\n    Represents an order with full details, including its ID, state, and associated UTC timestamps.\n\n    Attributes:\n        order_id: Unique identifier of the order.\n        order: The details of the order.\n        state_detail: Details of the order's current state.\n        open_quantity: Remaining open quantity for this order.\n        filled_quantity: Filled quantity for this order.\n        create_time: UTC Timestamp when the order was created.\n        modification_time: UTC Timestamp of the last update to the order.\n    \"\"\"\n\n    order_id: int\n    order: Order\n    state_detail: StateDetail\n    open_quantity: Power\n    filled_quantity: Power\n    create_time: datetime\n    modification_time: datetime\n\n    def __post_init__(self) -&gt; None:\n        \"\"\"\n        Post initialization checks to ensure that all datetimes are UTC.\n\n        Raises:\n            ValueError: If create_time or modification_time do not have timezone information.\n\n        \"\"\"\n        if self.create_time.tzinfo is None:\n            raise ValueError(\"Create time must have timezone information\")\n        if self.create_time.tzinfo != timezone.utc:\n            _logger.warning(\"Create time is not in UTC timezone. Converting to UTC.\")\n            self.create_time = self.create_time.astimezone(timezone.utc)\n\n        if self.modification_time.tzinfo is None:\n            raise ValueError(\"Modification time must have timezone information\")\n        if self.modification_time.tzinfo != timezone.utc:\n            _logger.warning(\n                \"Modification time is not in UTC timezone. Converting to UTC.\"\n            )\n            self.modification_time = self.modification_time.astimezone(timezone.utc)\n\n    @classmethod\n    def from_pb(cls, order_detail: electricity_trading_pb2.OrderDetail) -&gt; Self:\n        \"\"\"Convert a protobuf OrderDetail to OrderDetail object.\n\n        Args:\n            order_detail: OrderDetail to convert.\n\n        Returns:\n            OrderDetail object corresponding to the protobuf message.\n        \"\"\"\n        return cls(\n            order_id=order_detail.order_id,\n            order=Order.from_pb(order_detail.order),\n            state_detail=StateDetail.from_pb(order_detail.state_detail),\n            open_quantity=Power.from_pb(order_detail.open_quantity),\n            filled_quantity=Power.from_pb(order_detail.filled_quantity),\n            create_time=order_detail.create_time.ToDatetime(tzinfo=timezone.utc),\n            modification_time=order_detail.modification_time.ToDatetime(\n                tzinfo=timezone.utc\n            ),\n        )\n\n    def to_pb(self) -&gt; electricity_trading_pb2.OrderDetail:\n        \"\"\"Convert an OrderDetail object to protobuf OrderDetail.\n\n        Returns:\n            Protobuf message corresponding to the OrderDetail object.\n        \"\"\"\n        create_time = timestamp_pb2.Timestamp()\n        create_time.FromDatetime(self.create_time)\n        modification_time = timestamp_pb2.Timestamp()\n        modification_time.FromDatetime(self.modification_time)\n\n        return electricity_trading_pb2.OrderDetail(\n            order_id=self.order_id,\n            order=self.order.to_pb(),\n            state_detail=self.state_detail.to_pb(),\n            open_quantity=self.open_quantity.to_pb(),\n            filled_quantity=self.filled_quantity.to_pb(),\n            create_time=create_time,\n            modification_time=modification_time,\n        )\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderDetail-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderDetail.__post_init__","title":"__post_init__","text":"<pre><code>__post_init__() -&gt; None\n</code></pre> <p>Post initialization checks to ensure that all datetimes are UTC.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If create_time or modification_time do not have timezone information.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>def __post_init__(self) -&gt; None:\n    \"\"\"\n    Post initialization checks to ensure that all datetimes are UTC.\n\n    Raises:\n        ValueError: If create_time or modification_time do not have timezone information.\n\n    \"\"\"\n    if self.create_time.tzinfo is None:\n        raise ValueError(\"Create time must have timezone information\")\n    if self.create_time.tzinfo != timezone.utc:\n        _logger.warning(\"Create time is not in UTC timezone. Converting to UTC.\")\n        self.create_time = self.create_time.astimezone(timezone.utc)\n\n    if self.modification_time.tzinfo is None:\n        raise ValueError(\"Modification time must have timezone information\")\n    if self.modification_time.tzinfo != timezone.utc:\n        _logger.warning(\n            \"Modification time is not in UTC timezone. Converting to UTC.\"\n        )\n        self.modification_time = self.modification_time.astimezone(timezone.utc)\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderDetail.from_pb","title":"from_pb  <code>classmethod</code>","text":"<pre><code>from_pb(order_detail: OrderDetail) -&gt; Self\n</code></pre> <p>Convert a protobuf OrderDetail to OrderDetail object.</p> PARAMETER DESCRIPTION <code>order_detail</code> <p>OrderDetail to convert.</p> <p> TYPE: <code>OrderDetail</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>OrderDetail object corresponding to the protobuf message.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>@classmethod\ndef from_pb(cls, order_detail: electricity_trading_pb2.OrderDetail) -&gt; Self:\n    \"\"\"Convert a protobuf OrderDetail to OrderDetail object.\n\n    Args:\n        order_detail: OrderDetail to convert.\n\n    Returns:\n        OrderDetail object corresponding to the protobuf message.\n    \"\"\"\n    return cls(\n        order_id=order_detail.order_id,\n        order=Order.from_pb(order_detail.order),\n        state_detail=StateDetail.from_pb(order_detail.state_detail),\n        open_quantity=Power.from_pb(order_detail.open_quantity),\n        filled_quantity=Power.from_pb(order_detail.filled_quantity),\n        create_time=order_detail.create_time.ToDatetime(tzinfo=timezone.utc),\n        modification_time=order_detail.modification_time.ToDatetime(\n            tzinfo=timezone.utc\n        ),\n    )\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderDetail.to_pb","title":"to_pb","text":"<pre><code>to_pb() -&gt; OrderDetail\n</code></pre> <p>Convert an OrderDetail object to protobuf OrderDetail.</p> RETURNS DESCRIPTION <code>OrderDetail</code> <p>Protobuf message corresponding to the OrderDetail object.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>def to_pb(self) -&gt; electricity_trading_pb2.OrderDetail:\n    \"\"\"Convert an OrderDetail object to protobuf OrderDetail.\n\n    Returns:\n        Protobuf message corresponding to the OrderDetail object.\n    \"\"\"\n    create_time = timestamp_pb2.Timestamp()\n    create_time.FromDatetime(self.create_time)\n    modification_time = timestamp_pb2.Timestamp()\n    modification_time.FromDatetime(self.modification_time)\n\n    return electricity_trading_pb2.OrderDetail(\n        order_id=self.order_id,\n        order=self.order.to_pb(),\n        state_detail=self.state_detail.to_pb(),\n        open_quantity=self.open_quantity.to_pb(),\n        filled_quantity=self.filled_quantity.to_pb(),\n        create_time=create_time,\n        modification_time=modification_time,\n    )\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderExecutionOption","title":"frequenz.client.electricity_trading.OrderExecutionOption","text":"<p>               Bases: <code>Enum</code></p> <p>Specific behavior for the execution of an order.</p> <p>These options provide control on how an order is handled in the market.</p> <p>If no OrderExecutionOption is set, the order remains open until it's fully fulfilled, cancelled by the client, <code>valid_until</code> timestamp is reached, or the end of the trading session.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>class OrderExecutionOption(enum.Enum):\n    \"\"\"\n    Specific behavior for the execution of an order.\n\n    These options provide control on how an order is handled in the market.\n\n    If no OrderExecutionOption is set, the order remains open until it's fully\n    fulfilled, cancelled by the client, `valid_until` timestamp is reached, or\n    the end of the trading session.\n    \"\"\"\n\n    UNSPECIFIED = (\n        electricity_trading_pb2.OrderExecutionOption.ORDER_EXECUTION_OPTION_UNSPECIFIED\n    )\n    \"\"\"The order execution option has not been set.\"\"\"\n\n    AON = electricity_trading_pb2.OrderExecutionOption.ORDER_EXECUTION_OPTION_AON\n    \"\"\"All or None: Order must be executed in its entirety, or not executed at all.\"\"\"\n\n    FOK = electricity_trading_pb2.OrderExecutionOption.ORDER_EXECUTION_OPTION_FOK\n    \"\"\"Fill or Kill: Order must be executed immediately in its entirety, or not at all.\"\"\"\n\n    IOC = electricity_trading_pb2.OrderExecutionOption.ORDER_EXECUTION_OPTION_IOC\n    \"\"\"Immediate or Cancel: Any portion of an order that cannot be filled \\\n    immediately will be cancelled.\"\"\"\n\n    @classmethod\n    def from_pb(\n        cls,\n        order_execution_option: electricity_trading_pb2.OrderExecutionOption.ValueType,\n    ) -&gt; \"OrderExecutionOption\":\n        \"\"\"Convert a protobuf OrderExecutionOption value to OrderExecutionOption enum.\n\n        Args:\n            order_execution_option: order execution option to convert.\n\n        Returns:\n            Enum value corresponding to the protobuf message.\n        \"\"\"\n        if not any(e.value == order_execution_option for e in OrderExecutionOption):\n            _logger.warning(\n                \"Unknown forecast feature %s. Returning UNSPECIFIED.\",\n                order_execution_option,\n            )\n            return cls.UNSPECIFIED\n\n        return OrderExecutionOption(order_execution_option)\n\n    def to_pb(self) -&gt; electricity_trading_pb2.OrderExecutionOption.ValueType:\n        \"\"\"Convert a OrderExecutionOption object to protobuf OrderExecutionOption.\n\n        Returns:\n            Protobuf message corresponding to the OrderExecutionOption object.\n        \"\"\"\n        return electricity_trading_pb2.OrderExecutionOption.ValueType(self.value)\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderExecutionOption-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderExecutionOption.AON","title":"AON  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>AON = ORDER_EXECUTION_OPTION_AON\n</code></pre> <p>All or None: Order must be executed in its entirety, or not executed at all.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderExecutionOption.FOK","title":"FOK  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FOK = ORDER_EXECUTION_OPTION_FOK\n</code></pre> <p>Fill or Kill: Order must be executed immediately in its entirety, or not at all.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderExecutionOption.IOC","title":"IOC  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>IOC = ORDER_EXECUTION_OPTION_IOC\n</code></pre> <p>Immediate or Cancel: Any portion of an order that cannot be filled     immediately will be cancelled.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderExecutionOption.UNSPECIFIED","title":"UNSPECIFIED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>UNSPECIFIED = ORDER_EXECUTION_OPTION_UNSPECIFIED\n</code></pre> <p>The order execution option has not been set.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderExecutionOption-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderExecutionOption.from_pb","title":"from_pb  <code>classmethod</code>","text":"<pre><code>from_pb(\n    order_execution_option: ValueType,\n) -&gt; \"OrderExecutionOption\"\n</code></pre> <p>Convert a protobuf OrderExecutionOption value to OrderExecutionOption enum.</p> PARAMETER DESCRIPTION <code>order_execution_option</code> <p>order execution option to convert.</p> <p> TYPE: <code>ValueType</code> </p> RETURNS DESCRIPTION <code>'OrderExecutionOption'</code> <p>Enum value corresponding to the protobuf message.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>@classmethod\ndef from_pb(\n    cls,\n    order_execution_option: electricity_trading_pb2.OrderExecutionOption.ValueType,\n) -&gt; \"OrderExecutionOption\":\n    \"\"\"Convert a protobuf OrderExecutionOption value to OrderExecutionOption enum.\n\n    Args:\n        order_execution_option: order execution option to convert.\n\n    Returns:\n        Enum value corresponding to the protobuf message.\n    \"\"\"\n    if not any(e.value == order_execution_option for e in OrderExecutionOption):\n        _logger.warning(\n            \"Unknown forecast feature %s. Returning UNSPECIFIED.\",\n            order_execution_option,\n        )\n        return cls.UNSPECIFIED\n\n    return OrderExecutionOption(order_execution_option)\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderExecutionOption.to_pb","title":"to_pb","text":"<pre><code>to_pb() -&gt; ValueType\n</code></pre> <p>Convert a OrderExecutionOption object to protobuf OrderExecutionOption.</p> RETURNS DESCRIPTION <code>ValueType</code> <p>Protobuf message corresponding to the OrderExecutionOption object.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>def to_pb(self) -&gt; electricity_trading_pb2.OrderExecutionOption.ValueType:\n    \"\"\"Convert a OrderExecutionOption object to protobuf OrderExecutionOption.\n\n    Returns:\n        Protobuf message corresponding to the OrderExecutionOption object.\n    \"\"\"\n    return electricity_trading_pb2.OrderExecutionOption.ValueType(self.value)\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderState","title":"frequenz.client.electricity_trading.OrderState","text":"<p>               Bases: <code>Enum</code></p> <p>State of an order.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>class OrderState(enum.Enum):\n    \"\"\"State of an order.\"\"\"\n\n    UNSPECIFIED = electricity_trading_pb2.OrderState.ORDER_STATE_UNSPECIFIED\n    \"\"\"The order state is not known. Usually the default state of a newly created order object\n    before any operations have been applied.\"\"\"\n\n    PENDING = electricity_trading_pb2.OrderState.ORDER_STATE_PENDING\n    \"\"\"The order has been sent to the marketplace but has not yet been confirmed. This can be due\n    to awaiting validation or system processing.\"\"\"\n\n    ACTIVE = electricity_trading_pb2.OrderState.ORDER_STATE_ACTIVE\n    \"\"\"The order has been confirmed and is open in the market. It may be unfilled or partially\n    filled.\"\"\"\n\n    FILLED = electricity_trading_pb2.OrderState.ORDER_STATE_FILLED\n    \"\"\"The order has been completely filled and there are no remaining quantities on the order.\"\"\"\n\n    CANCELED = electricity_trading_pb2.OrderState.ORDER_STATE_CANCELED\n    \"\"\"The order has been canceled. This can occur due to a cancellation request by the market\n    participant, system, or market operator.\"\"\"\n\n    EXPIRED = electricity_trading_pb2.OrderState.ORDER_STATE_EXPIRED\n    \"\"\"The order has not been filled within the defined duration and has expired.\"\"\"\n\n    FAILED = electricity_trading_pb2.OrderState.ORDER_STATE_FAILED\n    \"\"\"The order submission failed and was unable to be placed on the order book, usually due to a\n    validation error or system issue.\"\"\"\n\n    HIBERNATE = electricity_trading_pb2.OrderState.ORDER_STATE_HIBERNATE\n    \"\"\"The order has been entered into the system but is not currently exposed to the market. This\n    could be due to certain conditions not yet being met.\"\"\"\n\n    @classmethod\n    def from_pb(\n        cls, order_state: electricity_trading_pb2.OrderState.ValueType\n    ) -&gt; \"OrderState\":\n        \"\"\"Convert a protobuf OrderState value to OrderState enum.\n\n        Args:\n            order_state: Order state to convert.\n\n        Returns:\n            Enum value corresponding to the protobuf message.\n        \"\"\"\n        if not any(e.value == order_state for e in cls):\n            _logger.warning(\n                \"Unknown order state %s. Returning UNSPECIFIED.\", order_state\n            )\n            return cls.UNSPECIFIED\n\n        return cls(order_state)\n\n    def to_pb(self) -&gt; electricity_trading_pb2.OrderState.ValueType:\n        \"\"\"Convert an OrderState enum to protobuf OrderState value.\n\n        Returns:\n            Protobuf message corresponding to the OrderState enum.\n        \"\"\"\n        return self.value\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderState-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderState.ACTIVE","title":"ACTIVE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ACTIVE = ORDER_STATE_ACTIVE\n</code></pre> <p>The order has been confirmed and is open in the market. It may be unfilled or partially filled.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderState.CANCELED","title":"CANCELED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CANCELED = ORDER_STATE_CANCELED\n</code></pre> <p>The order has been canceled. This can occur due to a cancellation request by the market participant, system, or market operator.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderState.EXPIRED","title":"EXPIRED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>EXPIRED = ORDER_STATE_EXPIRED\n</code></pre> <p>The order has not been filled within the defined duration and has expired.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderState.FAILED","title":"FAILED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FAILED = ORDER_STATE_FAILED\n</code></pre> <p>The order submission failed and was unable to be placed on the order book, usually due to a validation error or system issue.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderState.FILLED","title":"FILLED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FILLED = ORDER_STATE_FILLED\n</code></pre> <p>The order has been completely filled and there are no remaining quantities on the order.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderState.HIBERNATE","title":"HIBERNATE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>HIBERNATE = ORDER_STATE_HIBERNATE\n</code></pre> <p>The order has been entered into the system but is not currently exposed to the market. This could be due to certain conditions not yet being met.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderState.PENDING","title":"PENDING  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PENDING = ORDER_STATE_PENDING\n</code></pre> <p>The order has been sent to the marketplace but has not yet been confirmed. This can be due to awaiting validation or system processing.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderState.UNSPECIFIED","title":"UNSPECIFIED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>UNSPECIFIED = ORDER_STATE_UNSPECIFIED\n</code></pre> <p>The order state is not known. Usually the default state of a newly created order object before any operations have been applied.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderState-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderState.from_pb","title":"from_pb  <code>classmethod</code>","text":"<pre><code>from_pb(order_state: ValueType) -&gt; 'OrderState'\n</code></pre> <p>Convert a protobuf OrderState value to OrderState enum.</p> PARAMETER DESCRIPTION <code>order_state</code> <p>Order state to convert.</p> <p> TYPE: <code>ValueType</code> </p> RETURNS DESCRIPTION <code>'OrderState'</code> <p>Enum value corresponding to the protobuf message.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>@classmethod\ndef from_pb(\n    cls, order_state: electricity_trading_pb2.OrderState.ValueType\n) -&gt; \"OrderState\":\n    \"\"\"Convert a protobuf OrderState value to OrderState enum.\n\n    Args:\n        order_state: Order state to convert.\n\n    Returns:\n        Enum value corresponding to the protobuf message.\n    \"\"\"\n    if not any(e.value == order_state for e in cls):\n        _logger.warning(\n            \"Unknown order state %s. Returning UNSPECIFIED.\", order_state\n        )\n        return cls.UNSPECIFIED\n\n    return cls(order_state)\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderState.to_pb","title":"to_pb","text":"<pre><code>to_pb() -&gt; ValueType\n</code></pre> <p>Convert an OrderState enum to protobuf OrderState value.</p> RETURNS DESCRIPTION <code>ValueType</code> <p>Protobuf message corresponding to the OrderState enum.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>def to_pb(self) -&gt; electricity_trading_pb2.OrderState.ValueType:\n    \"\"\"Convert an OrderState enum to protobuf OrderState value.\n\n    Returns:\n        Protobuf message corresponding to the OrderState enum.\n    \"\"\"\n    return self.value\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderType","title":"frequenz.client.electricity_trading.OrderType","text":"<p>               Bases: <code>Enum</code></p> <p>Type of the order (specifies how the order is to be executed in the market).</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>class OrderType(enum.Enum):\n    \"\"\"Type of the order (specifies how the order is to be executed in the market).\"\"\"\n\n    UNSPECIFIED = electricity_trading_pb2.OrderType.ORDER_TYPE_UNSPECIFIED\n    \"\"\"The order type has not been set.\"\"\"\n\n    LIMIT = electricity_trading_pb2.OrderType.ORDER_TYPE_LIMIT\n    \"\"\"Order to buy or sell at a specific price or better.\n    It remains active until it is filled, cancelled, or expired.\"\"\"\n\n    STOP_LIMIT = electricity_trading_pb2.OrderType.ORDER_TYPE_STOP_LIMIT\n    \"\"\"An order that will be executed at a specified price,\n    or better, after a given stop price has been reached.\"\"\"\n\n    ICEBERG = electricity_trading_pb2.OrderType.ORDER_TYPE_ICEBERG\n    \"\"\"A large order divided into smaller lots to hide the actual order quantity.\n    Only the visible part of the order is shown in the order book.\"\"\"\n\n    BLOCK = electricity_trading_pb2.OrderType.ORDER_TYPE_BLOCK\n    \"\"\"User defined block order, generally a large quantity order filled all at once.\n    (Not yet supported).\"\"\"\n\n    BALANCE = electricity_trading_pb2.OrderType.ORDER_TYPE_BALANCE\n    \"\"\"Balance order aims to balance supply and demand, usually at\n    a specific location or within a system.(Not yet supported).\"\"\"\n\n    PREARRANGED = electricity_trading_pb2.OrderType.ORDER_TYPE_PREARRANGED\n    \"\"\"On exchange prearranged trade, a trade that has been privately\n    negotiated and then submitted to the exchange. (Not yet supported).\"\"\"\n\n    PRIVATE = electricity_trading_pb2.OrderType.ORDER_TYPE_PRIVATE\n    \"\"\"Private and confidential trade, not visible in the public\n    order book and has no market impact. (Not yet supported).\"\"\"\n\n    @classmethod\n    def from_pb(\n        cls, order_type: electricity_trading_pb2.OrderType.ValueType\n    ) -&gt; \"OrderType\":\n        \"\"\"Convert a protobuf OrderType value to OrderType enum.\n\n        Args:\n            order_type: Order type to convert.\n\n        Returns:\n            Enum value corresponding to the protobuf message.\n        \"\"\"\n        if not any(e.value == order_type for e in cls):\n            _logger.warning(\"Unknown order type %s. Returning UNSPECIFIED.\", order_type)\n            return cls.UNSPECIFIED\n\n        return cls(order_type)\n\n    def to_pb(self) -&gt; electricity_trading_pb2.OrderType.ValueType:\n        \"\"\"Convert an OrderType enum to protobuf OrderType value.\n\n        Returns:\n            Protobuf message corresponding to the OrderType enum.\n        \"\"\"\n        return self.value\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderType-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderType.BALANCE","title":"BALANCE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>BALANCE = ORDER_TYPE_BALANCE\n</code></pre> <p>Balance order aims to balance supply and demand, usually at a specific location or within a system.(Not yet supported).</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderType.BLOCK","title":"BLOCK  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>BLOCK = ORDER_TYPE_BLOCK\n</code></pre> <p>User defined block order, generally a large quantity order filled all at once. (Not yet supported).</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderType.ICEBERG","title":"ICEBERG  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ICEBERG = ORDER_TYPE_ICEBERG\n</code></pre> <p>A large order divided into smaller lots to hide the actual order quantity. Only the visible part of the order is shown in the order book.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderType.LIMIT","title":"LIMIT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>LIMIT = ORDER_TYPE_LIMIT\n</code></pre> <p>Order to buy or sell at a specific price or better. It remains active until it is filled, cancelled, or expired.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderType.PREARRANGED","title":"PREARRANGED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PREARRANGED = ORDER_TYPE_PREARRANGED\n</code></pre> <p>On exchange prearranged trade, a trade that has been privately negotiated and then submitted to the exchange. (Not yet supported).</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderType.PRIVATE","title":"PRIVATE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PRIVATE = ORDER_TYPE_PRIVATE\n</code></pre> <p>Private and confidential trade, not visible in the public order book and has no market impact. (Not yet supported).</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderType.STOP_LIMIT","title":"STOP_LIMIT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>STOP_LIMIT = ORDER_TYPE_STOP_LIMIT\n</code></pre> <p>An order that will be executed at a specified price, or better, after a given stop price has been reached.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderType.UNSPECIFIED","title":"UNSPECIFIED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>UNSPECIFIED = ORDER_TYPE_UNSPECIFIED\n</code></pre> <p>The order type has not been set.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderType-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderType.from_pb","title":"from_pb  <code>classmethod</code>","text":"<pre><code>from_pb(order_type: ValueType) -&gt; 'OrderType'\n</code></pre> <p>Convert a protobuf OrderType value to OrderType enum.</p> PARAMETER DESCRIPTION <code>order_type</code> <p>Order type to convert.</p> <p> TYPE: <code>ValueType</code> </p> RETURNS DESCRIPTION <code>'OrderType'</code> <p>Enum value corresponding to the protobuf message.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>@classmethod\ndef from_pb(\n    cls, order_type: electricity_trading_pb2.OrderType.ValueType\n) -&gt; \"OrderType\":\n    \"\"\"Convert a protobuf OrderType value to OrderType enum.\n\n    Args:\n        order_type: Order type to convert.\n\n    Returns:\n        Enum value corresponding to the protobuf message.\n    \"\"\"\n    if not any(e.value == order_type for e in cls):\n        _logger.warning(\"Unknown order type %s. Returning UNSPECIFIED.\", order_type)\n        return cls.UNSPECIFIED\n\n    return cls(order_type)\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderType.to_pb","title":"to_pb","text":"<pre><code>to_pb() -&gt; ValueType\n</code></pre> <p>Convert an OrderType enum to protobuf OrderType value.</p> RETURNS DESCRIPTION <code>ValueType</code> <p>Protobuf message corresponding to the OrderType enum.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>def to_pb(self) -&gt; electricity_trading_pb2.OrderType.ValueType:\n    \"\"\"Convert an OrderType enum to protobuf OrderType value.\n\n    Returns:\n        Protobuf message corresponding to the OrderType enum.\n    \"\"\"\n    return self.value\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Power","title":"frequenz.client.electricity_trading.Power  <code>dataclass</code>","text":"<p>Represents power unit in Megawatthours (MW).</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>@dataclass(frozen=True)\nclass Power:\n    \"\"\"Represents power unit in Megawatthours (MW).\"\"\"\n\n    mw: Decimal\n\n    @classmethod\n    def from_pb(cls, power: power_pb2.Power) -&gt; Self:\n        \"\"\"Convert a protobuf Power to Power object.\n\n        Args:\n            power: Power to convert.\n\n        Returns:\n            Power object corresponding to the protobuf message.\n        \"\"\"\n        return cls(mw=Decimal(power.mw.value))\n\n    def to_pb(self) -&gt; power_pb2.Power:\n        \"\"\"Convert a Power object to protobuf Power.\n\n        Returns:\n            Protobuf message corresponding to the Power object.\n        \"\"\"\n        decimal_mw = decimal_pb2.Decimal()\n        decimal_mw.value = str(self.mw)\n        return power_pb2.Power(mw=decimal_mw)\n\n    def __str__(self) -&gt; str:\n        \"\"\"Return the string representation of the Power object.\n\n        Returns:\n            The string representation of the Power object.\n        \"\"\"\n        return f\"{self.mw} MW\"\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Power-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Power.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return the string representation of the Power object.</p> RETURNS DESCRIPTION <code>str</code> <p>The string representation of the Power object.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return the string representation of the Power object.\n\n    Returns:\n        The string representation of the Power object.\n    \"\"\"\n    return f\"{self.mw} MW\"\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Power.from_pb","title":"from_pb  <code>classmethod</code>","text":"<pre><code>from_pb(power: Power) -&gt; Self\n</code></pre> <p>Convert a protobuf Power to Power object.</p> PARAMETER DESCRIPTION <code>power</code> <p>Power to convert.</p> <p> TYPE: <code>Power</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>Power object corresponding to the protobuf message.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>@classmethod\ndef from_pb(cls, power: power_pb2.Power) -&gt; Self:\n    \"\"\"Convert a protobuf Power to Power object.\n\n    Args:\n        power: Power to convert.\n\n    Returns:\n        Power object corresponding to the protobuf message.\n    \"\"\"\n    return cls(mw=Decimal(power.mw.value))\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Power.to_pb","title":"to_pb","text":"<pre><code>to_pb() -&gt; Power\n</code></pre> <p>Convert a Power object to protobuf Power.</p> RETURNS DESCRIPTION <code>Power</code> <p>Protobuf message corresponding to the Power object.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>def to_pb(self) -&gt; power_pb2.Power:\n    \"\"\"Convert a Power object to protobuf Power.\n\n    Returns:\n        Protobuf message corresponding to the Power object.\n    \"\"\"\n    decimal_mw = decimal_pb2.Decimal()\n    decimal_mw.value = str(self.mw)\n    return power_pb2.Power(mw=decimal_mw)\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Price","title":"frequenz.client.electricity_trading.Price  <code>dataclass</code>","text":"<p>Price of an order.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>@dataclass(frozen=True)\nclass Price:\n    \"\"\"Price of an order.\"\"\"\n\n    amount: Decimal\n    \"\"\"Amount of the price.\"\"\"\n\n    currency: Currency\n    \"\"\"Currency of the price.\"\"\"\n\n    @classmethod\n    def from_pb(cls, price: price_pb2.Price) -&gt; Self:\n        \"\"\"Convert a protobuf Price to Price object.\n\n        Args:\n            price: Price to convert.\n\n        Returns:\n            Price object corresponding to the protobuf message.\n        \"\"\"\n        return cls(\n            amount=Decimal(price.amount.value),\n            currency=Currency.from_pb(price.currency),\n        )\n\n    def to_pb(self) -&gt; price_pb2.Price:\n        \"\"\"Convert a Price object to protobuf Price.\n\n        Returns:\n            Protobuf message corresponding to the Price object.\n        \"\"\"\n        decimal_amount = decimal_pb2.Decimal()\n        decimal_amount.value = str(self.amount)\n        return price_pb2.Price(amount=decimal_amount, currency=self.currency.to_pb())\n\n    def __str__(self) -&gt; str:\n        \"\"\"Return string representation of the Price object.\n\n        Returns:\n            String representation of the Price object.\n        \"\"\"\n        return f\"{self.amount} {self.currency.name}\"\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Price-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Price.amount","title":"amount  <code>instance-attribute</code>","text":"<pre><code>amount: Decimal\n</code></pre> <p>Amount of the price.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Price.currency","title":"currency  <code>instance-attribute</code>","text":"<pre><code>currency: Currency\n</code></pre> <p>Currency of the price.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Price-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Price.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return string representation of the Price object.</p> RETURNS DESCRIPTION <code>str</code> <p>String representation of the Price object.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return string representation of the Price object.\n\n    Returns:\n        String representation of the Price object.\n    \"\"\"\n    return f\"{self.amount} {self.currency.name}\"\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Price.from_pb","title":"from_pb  <code>classmethod</code>","text":"<pre><code>from_pb(price: Price) -&gt; Self\n</code></pre> <p>Convert a protobuf Price to Price object.</p> PARAMETER DESCRIPTION <code>price</code> <p>Price to convert.</p> <p> TYPE: <code>Price</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>Price object corresponding to the protobuf message.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>@classmethod\ndef from_pb(cls, price: price_pb2.Price) -&gt; Self:\n    \"\"\"Convert a protobuf Price to Price object.\n\n    Args:\n        price: Price to convert.\n\n    Returns:\n        Price object corresponding to the protobuf message.\n    \"\"\"\n    return cls(\n        amount=Decimal(price.amount.value),\n        currency=Currency.from_pb(price.currency),\n    )\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Price.to_pb","title":"to_pb","text":"<pre><code>to_pb() -&gt; Price\n</code></pre> <p>Convert a Price object to protobuf Price.</p> RETURNS DESCRIPTION <code>Price</code> <p>Protobuf message corresponding to the Price object.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>def to_pb(self) -&gt; price_pb2.Price:\n    \"\"\"Convert a Price object to protobuf Price.\n\n    Returns:\n        Protobuf message corresponding to the Price object.\n    \"\"\"\n    decimal_amount = decimal_pb2.Decimal()\n    decimal_amount.value = str(self.amount)\n    return price_pb2.Price(amount=decimal_amount, currency=self.currency.to_pb())\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.PublicTrade","title":"frequenz.client.electricity_trading.PublicTrade  <code>dataclass</code>","text":"<p>Represents a public order in the market.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>@dataclass()\nclass PublicTrade:  # pylint: disable=too-many-instance-attributes\n    \"\"\"Represents a public order in the market.\"\"\"\n\n    public_trade_id: int\n    \"\"\"ID of the order from the public order book.\"\"\"\n\n    buy_delivery_area: DeliveryArea\n    \"\"\"Delivery area code of the buy side.\"\"\"\n\n    sell_delivery_area: DeliveryArea\n    \"\"\"Delivery area code of the sell side.\"\"\"\n\n    delivery_period: DeliveryPeriod\n    \"\"\"The delivery period for the contract.\"\"\"\n\n    execution_time: datetime\n    \"\"\"UTC Timestamp of the trades execution time.\"\"\"\n\n    price: Price\n    \"\"\"The limit price at which the contract is to be traded.\"\"\"\n\n    quantity: Power\n    \"\"\"The quantity of the contract being traded.\"\"\"\n\n    state: TradeState\n    \"\"\"State of the order.\"\"\"\n\n    def __post_init__(self) -&gt; None:\n        \"\"\"Post initialization checks to ensure that all datetimes are UTC.\"\"\"\n        if self.execution_time.tzinfo is None:\n            raise ValueError(\"Execution time must have timezone information\")\n        if self.execution_time.tzinfo != timezone.utc:\n            _logger.warning(\"Execution time is not in UTC timezone. Converting to UTC.\")\n            self.execution_time = self.execution_time.astimezone(timezone.utc)\n\n    @classmethod\n    def from_pb(cls, public_trade: electricity_trading_pb2.PublicTrade) -&gt; Self:\n        \"\"\"Convert a protobuf PublicTrade to PublicTrade object.\n\n        Args:\n            public_trade: PublicTrade to convert.\n\n        Returns:\n            PublicTrade object corresponding to the protobuf message.\n        \"\"\"\n        return cls(\n            public_trade_id=public_trade.id,\n            buy_delivery_area=DeliveryArea.from_pb(public_trade.buy_delivery_area),\n            sell_delivery_area=DeliveryArea.from_pb(public_trade.sell_delivery_area),\n            delivery_period=DeliveryPeriod.from_pb(public_trade.delivery_period),\n            execution_time=public_trade.execution_time.ToDatetime(tzinfo=timezone.utc),\n            price=Price.from_pb(public_trade.price),\n            quantity=Power.from_pb(public_trade.quantity),\n            state=TradeState.from_pb(public_trade.state),\n        )\n\n    def to_pb(self) -&gt; electricity_trading_pb2.PublicTrade:\n        \"\"\"Convert a PublicTrade object to protobuf PublicTrade.\n\n        Returns:\n            Protobuf message corresponding to the PublicTrade object.\n        \"\"\"\n        execution_time = timestamp_pb2.Timestamp()\n        execution_time.FromDatetime(self.execution_time)\n\n        return electricity_trading_pb2.PublicTrade(\n            id=self.public_trade_id,\n            buy_delivery_area=self.buy_delivery_area.to_pb(),\n            sell_delivery_area=self.sell_delivery_area.to_pb(),\n            delivery_period=self.delivery_period.to_pb(),\n            execution_time=execution_time,\n            price=self.price.to_pb(),\n            quantity=self.quantity.to_pb(),\n            state=electricity_trading_pb2.TradeState.ValueType(self.state.value),\n        )\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.PublicTrade-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.PublicTrade.buy_delivery_area","title":"buy_delivery_area  <code>instance-attribute</code>","text":"<pre><code>buy_delivery_area: DeliveryArea\n</code></pre> <p>Delivery area code of the buy side.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.PublicTrade.delivery_period","title":"delivery_period  <code>instance-attribute</code>","text":"<pre><code>delivery_period: DeliveryPeriod\n</code></pre> <p>The delivery period for the contract.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.PublicTrade.execution_time","title":"execution_time  <code>instance-attribute</code>","text":"<pre><code>execution_time: datetime\n</code></pre> <p>UTC Timestamp of the trades execution time.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.PublicTrade.price","title":"price  <code>instance-attribute</code>","text":"<pre><code>price: Price\n</code></pre> <p>The limit price at which the contract is to be traded.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.PublicTrade.public_trade_id","title":"public_trade_id  <code>instance-attribute</code>","text":"<pre><code>public_trade_id: int\n</code></pre> <p>ID of the order from the public order book.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.PublicTrade.quantity","title":"quantity  <code>instance-attribute</code>","text":"<pre><code>quantity: Power\n</code></pre> <p>The quantity of the contract being traded.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.PublicTrade.sell_delivery_area","title":"sell_delivery_area  <code>instance-attribute</code>","text":"<pre><code>sell_delivery_area: DeliveryArea\n</code></pre> <p>Delivery area code of the sell side.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.PublicTrade.state","title":"state  <code>instance-attribute</code>","text":"<pre><code>state: TradeState\n</code></pre> <p>State of the order.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.PublicTrade-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.PublicTrade.__post_init__","title":"__post_init__","text":"<pre><code>__post_init__() -&gt; None\n</code></pre> <p>Post initialization checks to ensure that all datetimes are UTC.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>def __post_init__(self) -&gt; None:\n    \"\"\"Post initialization checks to ensure that all datetimes are UTC.\"\"\"\n    if self.execution_time.tzinfo is None:\n        raise ValueError(\"Execution time must have timezone information\")\n    if self.execution_time.tzinfo != timezone.utc:\n        _logger.warning(\"Execution time is not in UTC timezone. Converting to UTC.\")\n        self.execution_time = self.execution_time.astimezone(timezone.utc)\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.PublicTrade.from_pb","title":"from_pb  <code>classmethod</code>","text":"<pre><code>from_pb(public_trade: PublicTrade) -&gt; Self\n</code></pre> <p>Convert a protobuf PublicTrade to PublicTrade object.</p> PARAMETER DESCRIPTION <code>public_trade</code> <p>PublicTrade to convert.</p> <p> TYPE: <code>PublicTrade</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>PublicTrade object corresponding to the protobuf message.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>@classmethod\ndef from_pb(cls, public_trade: electricity_trading_pb2.PublicTrade) -&gt; Self:\n    \"\"\"Convert a protobuf PublicTrade to PublicTrade object.\n\n    Args:\n        public_trade: PublicTrade to convert.\n\n    Returns:\n        PublicTrade object corresponding to the protobuf message.\n    \"\"\"\n    return cls(\n        public_trade_id=public_trade.id,\n        buy_delivery_area=DeliveryArea.from_pb(public_trade.buy_delivery_area),\n        sell_delivery_area=DeliveryArea.from_pb(public_trade.sell_delivery_area),\n        delivery_period=DeliveryPeriod.from_pb(public_trade.delivery_period),\n        execution_time=public_trade.execution_time.ToDatetime(tzinfo=timezone.utc),\n        price=Price.from_pb(public_trade.price),\n        quantity=Power.from_pb(public_trade.quantity),\n        state=TradeState.from_pb(public_trade.state),\n    )\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.PublicTrade.to_pb","title":"to_pb","text":"<pre><code>to_pb() -&gt; PublicTrade\n</code></pre> <p>Convert a PublicTrade object to protobuf PublicTrade.</p> RETURNS DESCRIPTION <code>PublicTrade</code> <p>Protobuf message corresponding to the PublicTrade object.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>def to_pb(self) -&gt; electricity_trading_pb2.PublicTrade:\n    \"\"\"Convert a PublicTrade object to protobuf PublicTrade.\n\n    Returns:\n        Protobuf message corresponding to the PublicTrade object.\n    \"\"\"\n    execution_time = timestamp_pb2.Timestamp()\n    execution_time.FromDatetime(self.execution_time)\n\n    return electricity_trading_pb2.PublicTrade(\n        id=self.public_trade_id,\n        buy_delivery_area=self.buy_delivery_area.to_pb(),\n        sell_delivery_area=self.sell_delivery_area.to_pb(),\n        delivery_period=self.delivery_period.to_pb(),\n        execution_time=execution_time,\n        price=self.price.to_pb(),\n        quantity=self.quantity.to_pb(),\n        state=electricity_trading_pb2.TradeState.ValueType(self.state.value),\n    )\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.PublicTradeFilter","title":"frequenz.client.electricity_trading.PublicTradeFilter  <code>dataclass</code>","text":"<p>Parameters for filtering the historic, publicly executed orders (trades).</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>@dataclass(frozen=True)\nclass PublicTradeFilter:\n    \"\"\"Parameters for filtering the historic, publicly executed orders (trades).\"\"\"\n\n    states: list[TradeState] | None = None\n    \"\"\"List of order states to filter for.\"\"\"\n\n    delivery_period: DeliveryPeriod | None = None\n    \"\"\"Delivery period to filter for.\"\"\"\n\n    buy_delivery_area: DeliveryArea | None = None\n    \"\"\"Delivery area to filter for on the buy side.\"\"\"\n\n    sell_delivery_area: DeliveryArea | None = None\n    \"\"\"Delivery area to filter for on the sell side.\"\"\"\n\n    def __eq__(self, other: object) -&gt; bool:\n        \"\"\"\n        Check if two PublicTradeFilter objects are equal.\n\n        Args:\n            other: PublicTradeFilter object to compare with.\n\n        Returns:\n            True if the two PublicTradeFilter objects are equal, False otherwise.\n        \"\"\"\n        if not isinstance(other, PublicTradeFilter):\n            return NotImplemented\n        return (\n            self.states == other.states\n            and self.delivery_period == other.delivery_period\n            and self.buy_delivery_area == other.buy_delivery_area\n            and self.sell_delivery_area == other.sell_delivery_area\n        )\n\n    def __hash__(self) -&gt; int:\n        \"\"\"\n        Create hash of the PublicTradeFilter object.\n\n        Returns:\n            Hash of the PublicTradeFilter object.\n        \"\"\"\n        return hash(\n            (\n                tuple(self.states) if self.states is not None else None,\n                self.delivery_period,\n                self.buy_delivery_area,\n                self.sell_delivery_area,\n            )\n        )\n\n    @classmethod\n    def from_pb(\n        cls, public_trade_filter: electricity_trading_pb2.PublicTradeFilter\n    ) -&gt; Self:\n        \"\"\"Convert a protobuf PublicTradeFilter to PublicTradeFilter object.\n\n        Args:\n            public_trade_filter: PublicTradeFilter to convert.\n\n        Returns:\n            PublicTradeFilter object corresponding to the protobuf message.\n        \"\"\"\n        return cls(\n            states=(\n                [TradeState.from_pb(state) for state in public_trade_filter.states]\n                if public_trade_filter.states\n                else None\n            ),\n            delivery_period=(\n                DeliveryPeriod.from_pb(public_trade_filter.delivery_period)\n                if public_trade_filter.HasField(\"delivery_period\")\n                else None\n            ),\n            buy_delivery_area=(\n                DeliveryArea.from_pb(public_trade_filter.buy_delivery_area)\n                if public_trade_filter.HasField(\"buy_delivery_area\")\n                else None\n            ),\n            sell_delivery_area=(\n                DeliveryArea.from_pb(public_trade_filter.sell_delivery_area)\n                if public_trade_filter.HasField(\"sell_delivery_area\")\n                else None\n            ),\n        )\n\n    def to_pb(self) -&gt; electricity_trading_pb2.PublicTradeFilter:\n        \"\"\"Convert a PublicTradeFilter object to protobuf PublicTradeFilter.\n\n        Returns:\n            Protobuf PublicTradeFilter corresponding to the object.\n        \"\"\"\n        return electricity_trading_pb2.PublicTradeFilter(\n            states=(\n                [\n                    electricity_trading_pb2.TradeState.ValueType(state.value)\n                    for state in self.states\n                ]\n                if self.states\n                else None\n            ),\n            delivery_period=(\n                self.delivery_period.to_pb() if self.delivery_period else None\n            ),\n            buy_delivery_area=(\n                self.buy_delivery_area.to_pb() if self.buy_delivery_area else None\n            ),\n            sell_delivery_area=(\n                self.sell_delivery_area.to_pb() if self.sell_delivery_area else None\n            ),\n        )\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.PublicTradeFilter-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.PublicTradeFilter.buy_delivery_area","title":"buy_delivery_area  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>buy_delivery_area: DeliveryArea | None = None\n</code></pre> <p>Delivery area to filter for on the buy side.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.PublicTradeFilter.delivery_period","title":"delivery_period  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>delivery_period: DeliveryPeriod | None = None\n</code></pre> <p>Delivery period to filter for.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.PublicTradeFilter.sell_delivery_area","title":"sell_delivery_area  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>sell_delivery_area: DeliveryArea | None = None\n</code></pre> <p>Delivery area to filter for on the sell side.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.PublicTradeFilter.states","title":"states  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>states: list[TradeState] | None = None\n</code></pre> <p>List of order states to filter for.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.PublicTradeFilter-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.PublicTradeFilter.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: object) -&gt; bool\n</code></pre> <p>Check if two PublicTradeFilter objects are equal.</p> PARAMETER DESCRIPTION <code>other</code> <p>PublicTradeFilter object to compare with.</p> <p> TYPE: <code>object</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if the two PublicTradeFilter objects are equal, False otherwise.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>def __eq__(self, other: object) -&gt; bool:\n    \"\"\"\n    Check if two PublicTradeFilter objects are equal.\n\n    Args:\n        other: PublicTradeFilter object to compare with.\n\n    Returns:\n        True if the two PublicTradeFilter objects are equal, False otherwise.\n    \"\"\"\n    if not isinstance(other, PublicTradeFilter):\n        return NotImplemented\n    return (\n        self.states == other.states\n        and self.delivery_period == other.delivery_period\n        and self.buy_delivery_area == other.buy_delivery_area\n        and self.sell_delivery_area == other.sell_delivery_area\n    )\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.PublicTradeFilter.__hash__","title":"__hash__","text":"<pre><code>__hash__() -&gt; int\n</code></pre> <p>Create hash of the PublicTradeFilter object.</p> RETURNS DESCRIPTION <code>int</code> <p>Hash of the PublicTradeFilter object.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>def __hash__(self) -&gt; int:\n    \"\"\"\n    Create hash of the PublicTradeFilter object.\n\n    Returns:\n        Hash of the PublicTradeFilter object.\n    \"\"\"\n    return hash(\n        (\n            tuple(self.states) if self.states is not None else None,\n            self.delivery_period,\n            self.buy_delivery_area,\n            self.sell_delivery_area,\n        )\n    )\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.PublicTradeFilter.from_pb","title":"from_pb  <code>classmethod</code>","text":"<pre><code>from_pb(public_trade_filter: PublicTradeFilter) -&gt; Self\n</code></pre> <p>Convert a protobuf PublicTradeFilter to PublicTradeFilter object.</p> PARAMETER DESCRIPTION <code>public_trade_filter</code> <p>PublicTradeFilter to convert.</p> <p> TYPE: <code>PublicTradeFilter</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>PublicTradeFilter object corresponding to the protobuf message.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>@classmethod\ndef from_pb(\n    cls, public_trade_filter: electricity_trading_pb2.PublicTradeFilter\n) -&gt; Self:\n    \"\"\"Convert a protobuf PublicTradeFilter to PublicTradeFilter object.\n\n    Args:\n        public_trade_filter: PublicTradeFilter to convert.\n\n    Returns:\n        PublicTradeFilter object corresponding to the protobuf message.\n    \"\"\"\n    return cls(\n        states=(\n            [TradeState.from_pb(state) for state in public_trade_filter.states]\n            if public_trade_filter.states\n            else None\n        ),\n        delivery_period=(\n            DeliveryPeriod.from_pb(public_trade_filter.delivery_period)\n            if public_trade_filter.HasField(\"delivery_period\")\n            else None\n        ),\n        buy_delivery_area=(\n            DeliveryArea.from_pb(public_trade_filter.buy_delivery_area)\n            if public_trade_filter.HasField(\"buy_delivery_area\")\n            else None\n        ),\n        sell_delivery_area=(\n            DeliveryArea.from_pb(public_trade_filter.sell_delivery_area)\n            if public_trade_filter.HasField(\"sell_delivery_area\")\n            else None\n        ),\n    )\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.PublicTradeFilter.to_pb","title":"to_pb","text":"<pre><code>to_pb() -&gt; PublicTradeFilter\n</code></pre> <p>Convert a PublicTradeFilter object to protobuf PublicTradeFilter.</p> RETURNS DESCRIPTION <code>PublicTradeFilter</code> <p>Protobuf PublicTradeFilter corresponding to the object.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>def to_pb(self) -&gt; electricity_trading_pb2.PublicTradeFilter:\n    \"\"\"Convert a PublicTradeFilter object to protobuf PublicTradeFilter.\n\n    Returns:\n        Protobuf PublicTradeFilter corresponding to the object.\n    \"\"\"\n    return electricity_trading_pb2.PublicTradeFilter(\n        states=(\n            [\n                electricity_trading_pb2.TradeState.ValueType(state.value)\n                for state in self.states\n            ]\n            if self.states\n            else None\n        ),\n        delivery_period=(\n            self.delivery_period.to_pb() if self.delivery_period else None\n        ),\n        buy_delivery_area=(\n            self.buy_delivery_area.to_pb() if self.buy_delivery_area else None\n        ),\n        sell_delivery_area=(\n            self.sell_delivery_area.to_pb() if self.sell_delivery_area else None\n        ),\n    )\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.StateDetail","title":"frequenz.client.electricity_trading.StateDetail  <code>dataclass</code>","text":"<p>Details about the current state of the order.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>@dataclass(frozen=True)\nclass StateDetail:\n    \"\"\"Details about the current state of the order.\"\"\"\n\n    state: OrderState\n    \"\"\"Current state of the order.\"\"\"\n\n    state_reason: StateReason\n    \"\"\"Reason for the current state.\"\"\"\n\n    market_actor: MarketActor\n    \"\"\"Actor responsible for the current state.\"\"\"\n\n    @classmethod\n    def from_pb(\n        cls, state_detail: electricity_trading_pb2.OrderDetail.StateDetail\n    ) -&gt; Self:\n        \"\"\"Convert a protobuf StateDetail to StateDetail object.\n\n        Args:\n            state_detail: StateDetail to convert.\n\n        Returns:\n            StateDetail object corresponding to the protobuf message.\n        \"\"\"\n        return cls(\n            state=OrderState.from_pb(state_detail.state),\n            state_reason=StateReason.from_pb(state_detail.state_reason),\n            market_actor=MarketActor.from_pb(state_detail.market_actor),\n        )\n\n    def to_pb(self) -&gt; electricity_trading_pb2.OrderDetail.StateDetail:\n        \"\"\"Convert a StateDetail object to protobuf StateDetail.\n\n        Returns:\n            Protobuf message corresponding to the StateDetail object.\n        \"\"\"\n        return electricity_trading_pb2.OrderDetail.StateDetail(\n            state=electricity_trading_pb2.OrderState.ValueType(self.state.value),\n            state_reason=electricity_trading_pb2.OrderDetail.StateDetail.StateReason.ValueType(\n                self.state_reason.value\n            ),\n            market_actor=electricity_trading_pb2.OrderDetail.StateDetail.MarketActor.ValueType(\n                self.market_actor.value\n            ),\n        )\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.StateDetail-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.StateDetail.market_actor","title":"market_actor  <code>instance-attribute</code>","text":"<pre><code>market_actor: MarketActor\n</code></pre> <p>Actor responsible for the current state.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.StateDetail.state","title":"state  <code>instance-attribute</code>","text":"<pre><code>state: OrderState\n</code></pre> <p>Current state of the order.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.StateDetail.state_reason","title":"state_reason  <code>instance-attribute</code>","text":"<pre><code>state_reason: StateReason\n</code></pre> <p>Reason for the current state.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.StateDetail-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.StateDetail.from_pb","title":"from_pb  <code>classmethod</code>","text":"<pre><code>from_pb(state_detail: StateDetail) -&gt; Self\n</code></pre> <p>Convert a protobuf StateDetail to StateDetail object.</p> PARAMETER DESCRIPTION <code>state_detail</code> <p>StateDetail to convert.</p> <p> TYPE: <code>StateDetail</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>StateDetail object corresponding to the protobuf message.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>@classmethod\ndef from_pb(\n    cls, state_detail: electricity_trading_pb2.OrderDetail.StateDetail\n) -&gt; Self:\n    \"\"\"Convert a protobuf StateDetail to StateDetail object.\n\n    Args:\n        state_detail: StateDetail to convert.\n\n    Returns:\n        StateDetail object corresponding to the protobuf message.\n    \"\"\"\n    return cls(\n        state=OrderState.from_pb(state_detail.state),\n        state_reason=StateReason.from_pb(state_detail.state_reason),\n        market_actor=MarketActor.from_pb(state_detail.market_actor),\n    )\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.StateDetail.to_pb","title":"to_pb","text":"<pre><code>to_pb() -&gt; StateDetail\n</code></pre> <p>Convert a StateDetail object to protobuf StateDetail.</p> RETURNS DESCRIPTION <code>StateDetail</code> <p>Protobuf message corresponding to the StateDetail object.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>def to_pb(self) -&gt; electricity_trading_pb2.OrderDetail.StateDetail:\n    \"\"\"Convert a StateDetail object to protobuf StateDetail.\n\n    Returns:\n        Protobuf message corresponding to the StateDetail object.\n    \"\"\"\n    return electricity_trading_pb2.OrderDetail.StateDetail(\n        state=electricity_trading_pb2.OrderState.ValueType(self.state.value),\n        state_reason=electricity_trading_pb2.OrderDetail.StateDetail.StateReason.ValueType(\n            self.state_reason.value\n        ),\n        market_actor=electricity_trading_pb2.OrderDetail.StateDetail.MarketActor.ValueType(\n            self.market_actor.value\n        ),\n    )\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.StateReason","title":"frequenz.client.electricity_trading.StateReason","text":"<p>               Bases: <code>Enum</code></p> <p>Reason that led to a state change.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>class StateReason(enum.Enum):\n    \"\"\"Reason that led to a state change.\"\"\"\n\n    UNSPECIFIED = (\n        electricity_trading_pb2.OrderDetail.StateDetail.StateReason.STATE_REASON_UNSPECIFIED\n    )\n    \"\"\"The reason for the state change has not been specified.\"\"\"\n\n    ADD = electricity_trading_pb2.OrderDetail.StateDetail.StateReason.STATE_REASON_ADD\n    \"\"\"The order was added.\"\"\"\n\n    MODIFY = (\n        electricity_trading_pb2.OrderDetail.StateDetail.StateReason.STATE_REASON_MODIFY\n    )\n    \"\"\"The order was modified.\"\"\"\n\n    DELETE = (\n        electricity_trading_pb2.OrderDetail.StateDetail.StateReason.STATE_REASON_DELETE\n    )\n    \"\"\"The order was deleted.\"\"\"\n\n    DEACTIVATE = (\n        electricity_trading_pb2.OrderDetail.StateDetail.StateReason.STATE_REASON_DEACTIVATE\n    )\n    \"\"\"The order was deactivated.\"\"\"\n\n    REJECT = (\n        electricity_trading_pb2.OrderDetail.StateDetail.StateReason.STATE_REASON_REJECT\n    )\n    \"\"\"The order was rejected.\"\"\"\n\n    FULL_EXECUTION = (\n        electricity_trading_pb2.OrderDetail.StateDetail.StateReason.STATE_REASON_FULL_EXECUTION\n    )\n    \"\"\"The order was fully executed.\"\"\"\n\n    PARTIAL_EXECUTION = (\n        electricity_trading_pb2.OrderDetail.StateDetail.StateReason.STATE_REASON_PARTIAL_EXECUTION\n    )\n    \"\"\"The order was partially executed.\"\"\"\n\n    ICEBERG_SLICE_ADD = (\n        electricity_trading_pb2.OrderDetail.StateDetail.StateReason.STATE_REASON_ICEBERG_SLICE_ADD\n    )\n    \"\"\"An iceberg slice was added.\"\"\"\n\n    VALIDATION_FAIL = (\n        electricity_trading_pb2.OrderDetail.StateDetail.StateReason.STATE_REASON_VALIDATION_FAIL\n    )\n    \"\"\"The order failed validation.\"\"\"\n\n    UNKNOWN_STATE = (\n        electricity_trading_pb2.OrderDetail.StateDetail.StateReason.STATE_REASON_UNKNOWN_STATE\n    )\n    \"\"\"The state of the order is unknown.\"\"\"\n\n    QUOTE_ADD = (\n        electricity_trading_pb2.OrderDetail.StateDetail.StateReason.STATE_REASON_QUOTE_ADD\n    )\n    \"\"\"A quote was added.\"\"\"\n\n    QUOTE_FULL_EXECUTION = (\n        electricity_trading_pb2.OrderDetail.StateDetail.StateReason.STATE_REASON_QUOTE_FULL_EXECUTION  # noqa: E501\n    )\n    \"\"\"A quote was fully executed.\"\"\"\n\n    QUOTE_PARTIAL_EXECUTION = (\n        electricity_trading_pb2.OrderDetail.StateDetail.StateReason.STATE_REASON_QUOTE_PARTIAL_EXECUTION  # noqa: E501\n    )\n    \"\"\"A quote was partially executed.\"\"\"\n\n    @classmethod\n    def from_pb(\n        cls,\n        state_reason: electricity_trading_pb2.OrderDetail.StateDetail.StateReason.ValueType,\n    ) -&gt; \"StateReason\":\n        \"\"\"Convert a protobuf StateReason value to StateReason enum.\n\n        Args:\n            state_reason: State reason to convert.\n\n        Returns:\n            Enum value corresponding to the protobuf message.\n        \"\"\"\n        if not any(e.value == state_reason for e in cls):\n            _logger.warning(\n                \"Unknown state reason %s. Returning UNSPECIFIED.\", state_reason\n            )\n            return cls.UNSPECIFIED\n\n        return cls(state_reason)\n\n    def to_pb(\n        self,\n    ) -&gt; electricity_trading_pb2.OrderDetail.StateDetail.StateReason.ValueType:\n        \"\"\"Convert a StateReason enum to protobuf StateReason value.\n\n        Returns:\n            Protobuf message corresponding to the StateReason enum.\n        \"\"\"\n        return self.value\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.StateReason-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.StateReason.ADD","title":"ADD  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ADD = STATE_REASON_ADD\n</code></pre> <p>The order was added.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.StateReason.DEACTIVATE","title":"DEACTIVATE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DEACTIVATE = STATE_REASON_DEACTIVATE\n</code></pre> <p>The order was deactivated.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.StateReason.DELETE","title":"DELETE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DELETE = STATE_REASON_DELETE\n</code></pre> <p>The order was deleted.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.StateReason.FULL_EXECUTION","title":"FULL_EXECUTION  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FULL_EXECUTION = STATE_REASON_FULL_EXECUTION\n</code></pre> <p>The order was fully executed.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.StateReason.ICEBERG_SLICE_ADD","title":"ICEBERG_SLICE_ADD  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ICEBERG_SLICE_ADD = STATE_REASON_ICEBERG_SLICE_ADD\n</code></pre> <p>An iceberg slice was added.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.StateReason.MODIFY","title":"MODIFY  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MODIFY = STATE_REASON_MODIFY\n</code></pre> <p>The order was modified.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.StateReason.PARTIAL_EXECUTION","title":"PARTIAL_EXECUTION  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PARTIAL_EXECUTION = STATE_REASON_PARTIAL_EXECUTION\n</code></pre> <p>The order was partially executed.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.StateReason.QUOTE_ADD","title":"QUOTE_ADD  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>QUOTE_ADD = STATE_REASON_QUOTE_ADD\n</code></pre> <p>A quote was added.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.StateReason.QUOTE_FULL_EXECUTION","title":"QUOTE_FULL_EXECUTION  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>QUOTE_FULL_EXECUTION = STATE_REASON_QUOTE_FULL_EXECUTION\n</code></pre> <p>A quote was fully executed.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.StateReason.QUOTE_PARTIAL_EXECUTION","title":"QUOTE_PARTIAL_EXECUTION  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>QUOTE_PARTIAL_EXECUTION = (\n    STATE_REASON_QUOTE_PARTIAL_EXECUTION\n)\n</code></pre> <p>A quote was partially executed.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.StateReason.REJECT","title":"REJECT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>REJECT = STATE_REASON_REJECT\n</code></pre> <p>The order was rejected.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.StateReason.UNKNOWN_STATE","title":"UNKNOWN_STATE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>UNKNOWN_STATE = STATE_REASON_UNKNOWN_STATE\n</code></pre> <p>The state of the order is unknown.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.StateReason.UNSPECIFIED","title":"UNSPECIFIED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>UNSPECIFIED = STATE_REASON_UNSPECIFIED\n</code></pre> <p>The reason for the state change has not been specified.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.StateReason.VALIDATION_FAIL","title":"VALIDATION_FAIL  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>VALIDATION_FAIL = STATE_REASON_VALIDATION_FAIL\n</code></pre> <p>The order failed validation.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.StateReason-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.StateReason.from_pb","title":"from_pb  <code>classmethod</code>","text":"<pre><code>from_pb(state_reason: ValueType) -&gt; 'StateReason'\n</code></pre> <p>Convert a protobuf StateReason value to StateReason enum.</p> PARAMETER DESCRIPTION <code>state_reason</code> <p>State reason to convert.</p> <p> TYPE: <code>ValueType</code> </p> RETURNS DESCRIPTION <code>'StateReason'</code> <p>Enum value corresponding to the protobuf message.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>@classmethod\ndef from_pb(\n    cls,\n    state_reason: electricity_trading_pb2.OrderDetail.StateDetail.StateReason.ValueType,\n) -&gt; \"StateReason\":\n    \"\"\"Convert a protobuf StateReason value to StateReason enum.\n\n    Args:\n        state_reason: State reason to convert.\n\n    Returns:\n        Enum value corresponding to the protobuf message.\n    \"\"\"\n    if not any(e.value == state_reason for e in cls):\n        _logger.warning(\n            \"Unknown state reason %s. Returning UNSPECIFIED.\", state_reason\n        )\n        return cls.UNSPECIFIED\n\n    return cls(state_reason)\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.StateReason.to_pb","title":"to_pb","text":"<pre><code>to_pb() -&gt; ValueType\n</code></pre> <p>Convert a StateReason enum to protobuf StateReason value.</p> RETURNS DESCRIPTION <code>ValueType</code> <p>Protobuf message corresponding to the StateReason enum.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>def to_pb(\n    self,\n) -&gt; electricity_trading_pb2.OrderDetail.StateDetail.StateReason.ValueType:\n    \"\"\"Convert a StateReason enum to protobuf StateReason value.\n\n    Returns:\n        Protobuf message corresponding to the StateReason enum.\n    \"\"\"\n    return self.value\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Trade","title":"frequenz.client.electricity_trading.Trade  <code>dataclass</code>","text":"<p>Represents a private trade in the electricity market.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>@dataclass()\nclass Trade:  # pylint: disable=too-many-instance-attributes\n    \"\"\"Represents a private trade in the electricity market.\"\"\"\n\n    id: int\n    \"\"\"ID of the trade.\"\"\"\n\n    order_id: int\n    \"\"\"ID of the corresponding order.\"\"\"\n\n    side: MarketSide\n    \"\"\"Indicates if the trade's order was on the Buy or Sell side of the\n    market.\"\"\"\n\n    delivery_area: DeliveryArea\n    \"\"\"Delivery area of the trade.\"\"\"\n\n    delivery_period: DeliveryPeriod\n    \"\"\"The delivery period for the contract.\"\"\"\n\n    execution_time: datetime\n    \"\"\"UTC Timestamp of the trade's execution time.\"\"\"\n\n    price: Price\n    \"\"\"The price at which the trade was executed.\"\"\"\n\n    quantity: Power\n    \"\"\"The executed quantity of the trade.\"\"\"\n\n    state: TradeState\n    \"\"\"Current state of the trade.\"\"\"\n\n    def __post_init__(self) -&gt; None:\n        \"\"\"Post initialization checks to ensure that all datetimes are UTC.\"\"\"\n        if self.execution_time.tzinfo is None:\n            raise ValueError(\"Execution time must have timezone information\")\n        if self.execution_time.tzinfo != timezone.utc:\n            _logger.warning(\"Execution timenis not in UTC timezone. Converting to UTC.\")\n            self.execution_time = self.execution_time.astimezone(timezone.utc)\n\n    @classmethod\n    def from_pb(cls, trade: electricity_trading_pb2.Trade) -&gt; Self:\n        \"\"\"Convert a protobuf Trade to Trade object.\n\n        Args:\n            trade: Trade to convert.\n\n        Returns:\n            Trade object corresponding to the protobuf message.\n        \"\"\"\n        return cls(\n            id=trade.id,\n            order_id=trade.order_id,\n            side=MarketSide.from_pb(trade.side),\n            delivery_area=DeliveryArea.from_pb(trade.delivery_area),\n            delivery_period=DeliveryPeriod.from_pb(trade.delivery_period),\n            execution_time=trade.execution_time.ToDatetime(tzinfo=timezone.utc),\n            price=Price.from_pb(trade.price),\n            quantity=Power.from_pb(trade.quantity),\n            state=TradeState.from_pb(trade.state),\n        )\n\n    def to_pb(self) -&gt; electricity_trading_pb2.Trade:\n        \"\"\"Convert a Trade object to protobuf Trade.\n\n        Returns:\n            Protobuf message corresponding to the Trade object.\n        \"\"\"\n        execution_time = timestamp_pb2.Timestamp()\n        execution_time.FromDatetime(self.execution_time)\n\n        return electricity_trading_pb2.Trade(\n            id=self.id,\n            order_id=self.order_id,\n            side=electricity_trading_pb2.MarketSide.ValueType(self.side.value),\n            delivery_area=self.delivery_area.to_pb(),\n            delivery_period=self.delivery_period.to_pb(),\n            execution_time=execution_time,\n            price=self.price.to_pb(),\n            quantity=self.quantity.to_pb(),\n            state=electricity_trading_pb2.TradeState.ValueType(self.state.value),\n        )\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Trade-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Trade.delivery_area","title":"delivery_area  <code>instance-attribute</code>","text":"<pre><code>delivery_area: DeliveryArea\n</code></pre> <p>Delivery area of the trade.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Trade.delivery_period","title":"delivery_period  <code>instance-attribute</code>","text":"<pre><code>delivery_period: DeliveryPeriod\n</code></pre> <p>The delivery period for the contract.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Trade.execution_time","title":"execution_time  <code>instance-attribute</code>","text":"<pre><code>execution_time: datetime\n</code></pre> <p>UTC Timestamp of the trade's execution time.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Trade.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: int\n</code></pre> <p>ID of the trade.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Trade.order_id","title":"order_id  <code>instance-attribute</code>","text":"<pre><code>order_id: int\n</code></pre> <p>ID of the corresponding order.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Trade.price","title":"price  <code>instance-attribute</code>","text":"<pre><code>price: Price\n</code></pre> <p>The price at which the trade was executed.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Trade.quantity","title":"quantity  <code>instance-attribute</code>","text":"<pre><code>quantity: Power\n</code></pre> <p>The executed quantity of the trade.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Trade.side","title":"side  <code>instance-attribute</code>","text":"<pre><code>side: MarketSide\n</code></pre> <p>Indicates if the trade's order was on the Buy or Sell side of the market.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Trade.state","title":"state  <code>instance-attribute</code>","text":"<pre><code>state: TradeState\n</code></pre> <p>Current state of the trade.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Trade-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Trade.__post_init__","title":"__post_init__","text":"<pre><code>__post_init__() -&gt; None\n</code></pre> <p>Post initialization checks to ensure that all datetimes are UTC.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>def __post_init__(self) -&gt; None:\n    \"\"\"Post initialization checks to ensure that all datetimes are UTC.\"\"\"\n    if self.execution_time.tzinfo is None:\n        raise ValueError(\"Execution time must have timezone information\")\n    if self.execution_time.tzinfo != timezone.utc:\n        _logger.warning(\"Execution timenis not in UTC timezone. Converting to UTC.\")\n        self.execution_time = self.execution_time.astimezone(timezone.utc)\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Trade.from_pb","title":"from_pb  <code>classmethod</code>","text":"<pre><code>from_pb(trade: Trade) -&gt; Self\n</code></pre> <p>Convert a protobuf Trade to Trade object.</p> PARAMETER DESCRIPTION <code>trade</code> <p>Trade to convert.</p> <p> TYPE: <code>Trade</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>Trade object corresponding to the protobuf message.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>@classmethod\ndef from_pb(cls, trade: electricity_trading_pb2.Trade) -&gt; Self:\n    \"\"\"Convert a protobuf Trade to Trade object.\n\n    Args:\n        trade: Trade to convert.\n\n    Returns:\n        Trade object corresponding to the protobuf message.\n    \"\"\"\n    return cls(\n        id=trade.id,\n        order_id=trade.order_id,\n        side=MarketSide.from_pb(trade.side),\n        delivery_area=DeliveryArea.from_pb(trade.delivery_area),\n        delivery_period=DeliveryPeriod.from_pb(trade.delivery_period),\n        execution_time=trade.execution_time.ToDatetime(tzinfo=timezone.utc),\n        price=Price.from_pb(trade.price),\n        quantity=Power.from_pb(trade.quantity),\n        state=TradeState.from_pb(trade.state),\n    )\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Trade.to_pb","title":"to_pb","text":"<pre><code>to_pb() -&gt; Trade\n</code></pre> <p>Convert a Trade object to protobuf Trade.</p> RETURNS DESCRIPTION <code>Trade</code> <p>Protobuf message corresponding to the Trade object.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>def to_pb(self) -&gt; electricity_trading_pb2.Trade:\n    \"\"\"Convert a Trade object to protobuf Trade.\n\n    Returns:\n        Protobuf message corresponding to the Trade object.\n    \"\"\"\n    execution_time = timestamp_pb2.Timestamp()\n    execution_time.FromDatetime(self.execution_time)\n\n    return electricity_trading_pb2.Trade(\n        id=self.id,\n        order_id=self.order_id,\n        side=electricity_trading_pb2.MarketSide.ValueType(self.side.value),\n        delivery_area=self.delivery_area.to_pb(),\n        delivery_period=self.delivery_period.to_pb(),\n        execution_time=execution_time,\n        price=self.price.to_pb(),\n        quantity=self.quantity.to_pb(),\n        state=electricity_trading_pb2.TradeState.ValueType(self.state.value),\n    )\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.TradeState","title":"frequenz.client.electricity_trading.TradeState","text":"<p>               Bases: <code>Enum</code></p> <p>State of a trade.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>class TradeState(enum.Enum):\n    \"\"\"State of a trade.\"\"\"\n\n    UNSPECIFIED = electricity_trading_pb2.TradeState.TRADE_STATE_UNSPECIFIED\n    \"\"\"The state is not known.\"\"\"\n\n    ACTIVE = electricity_trading_pb2.TradeState.TRADE_STATE_ACTIVE\n    \"\"\"The trade has been executed in the market.\"\"\"\n\n    CANCEL_REQUESTED = electricity_trading_pb2.TradeState.TRADE_STATE_CANCEL_REQUESTED\n    \"\"\"A cancellation request for the trade has been submitted.\"\"\"\n\n    CANCEL_REJECTED = electricity_trading_pb2.TradeState.TRADE_STATE_CANCEL_REJECTED\n    \"\"\"The trade cancellation request was rejected.\"\"\"\n\n    CANCELED = electricity_trading_pb2.TradeState.TRADE_STATE_CANCELED\n    \"\"\"The trade has been cancelled. This can occur due to a cancellation request by the market\n    participant, system, or market operator.\"\"\"\n\n    RECALL = electricity_trading_pb2.TradeState.TRADE_STATE_RECALLED\n    \"\"\"The trade has been recalled. This could be due to a system issue or a request from the market\n    participant or market operator.\"\"\"\n\n    RECALL_REQUESTED = electricity_trading_pb2.TradeState.TRADE_STATE_RECALL_REQUESTED\n    \"\"\"A recall request for the trade has been submitted.\"\"\"\n\n    RECALL_REJECTED = electricity_trading_pb2.TradeState.TRADE_STATE_RECALL_REJECTED\n    \"\"\"The trade recall request was rejected.\"\"\"\n\n    APPROVAL_REQUESTED = (\n        electricity_trading_pb2.TradeState.TRADE_STATE_APPROVAL_REQUESTED\n    )\n    \"\"\"An approval has been requested.\"\"\"\n\n    @classmethod\n    def from_pb(\n        cls, trade_state: electricity_trading_pb2.TradeState.ValueType\n    ) -&gt; \"TradeState\":\n        \"\"\"Convert a protobuf TradeState value to TradeState enum.\n\n        Args:\n            trade_state: The trade state to convert.\n\n        Returns:\n            Enum value corresponding to the protobuf message.\n        \"\"\"\n        if not any(e.value == trade_state for e in cls):\n            _logger.warning(\n                \"Unknown trade state %s. Returning UNSPECIFIED.\", trade_state\n            )\n            return cls.UNSPECIFIED\n\n        return cls(trade_state)\n\n    def to_pb(self) -&gt; electricity_trading_pb2.TradeState.ValueType:\n        \"\"\"Convert a TradeState enum to protobuf TradeState value.\n\n        Returns:\n            Protobuf message corresponding to the TradeState enum.\n        \"\"\"\n        return self.value\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.TradeState-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.TradeState.ACTIVE","title":"ACTIVE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ACTIVE = TRADE_STATE_ACTIVE\n</code></pre> <p>The trade has been executed in the market.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.TradeState.APPROVAL_REQUESTED","title":"APPROVAL_REQUESTED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>APPROVAL_REQUESTED = TRADE_STATE_APPROVAL_REQUESTED\n</code></pre> <p>An approval has been requested.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.TradeState.CANCELED","title":"CANCELED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CANCELED = TRADE_STATE_CANCELED\n</code></pre> <p>The trade has been cancelled. This can occur due to a cancellation request by the market participant, system, or market operator.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.TradeState.CANCEL_REJECTED","title":"CANCEL_REJECTED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CANCEL_REJECTED = TRADE_STATE_CANCEL_REJECTED\n</code></pre> <p>The trade cancellation request was rejected.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.TradeState.CANCEL_REQUESTED","title":"CANCEL_REQUESTED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CANCEL_REQUESTED = TRADE_STATE_CANCEL_REQUESTED\n</code></pre> <p>A cancellation request for the trade has been submitted.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.TradeState.RECALL","title":"RECALL  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>RECALL = TRADE_STATE_RECALLED\n</code></pre> <p>The trade has been recalled. This could be due to a system issue or a request from the market participant or market operator.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.TradeState.RECALL_REJECTED","title":"RECALL_REJECTED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>RECALL_REJECTED = TRADE_STATE_RECALL_REJECTED\n</code></pre> <p>The trade recall request was rejected.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.TradeState.RECALL_REQUESTED","title":"RECALL_REQUESTED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>RECALL_REQUESTED = TRADE_STATE_RECALL_REQUESTED\n</code></pre> <p>A recall request for the trade has been submitted.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.TradeState.UNSPECIFIED","title":"UNSPECIFIED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>UNSPECIFIED = TRADE_STATE_UNSPECIFIED\n</code></pre> <p>The state is not known.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.TradeState-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.TradeState.from_pb","title":"from_pb  <code>classmethod</code>","text":"<pre><code>from_pb(trade_state: ValueType) -&gt; 'TradeState'\n</code></pre> <p>Convert a protobuf TradeState value to TradeState enum.</p> PARAMETER DESCRIPTION <code>trade_state</code> <p>The trade state to convert.</p> <p> TYPE: <code>ValueType</code> </p> RETURNS DESCRIPTION <code>'TradeState'</code> <p>Enum value corresponding to the protobuf message.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>@classmethod\ndef from_pb(\n    cls, trade_state: electricity_trading_pb2.TradeState.ValueType\n) -&gt; \"TradeState\":\n    \"\"\"Convert a protobuf TradeState value to TradeState enum.\n\n    Args:\n        trade_state: The trade state to convert.\n\n    Returns:\n        Enum value corresponding to the protobuf message.\n    \"\"\"\n    if not any(e.value == trade_state for e in cls):\n        _logger.warning(\n            \"Unknown trade state %s. Returning UNSPECIFIED.\", trade_state\n        )\n        return cls.UNSPECIFIED\n\n    return cls(trade_state)\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.TradeState.to_pb","title":"to_pb","text":"<pre><code>to_pb() -&gt; ValueType\n</code></pre> <p>Convert a TradeState enum to protobuf TradeState value.</p> RETURNS DESCRIPTION <code>ValueType</code> <p>Protobuf message corresponding to the TradeState enum.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>def to_pb(self) -&gt; electricity_trading_pb2.TradeState.ValueType:\n    \"\"\"Convert a TradeState enum to protobuf TradeState value.\n\n    Returns:\n        Protobuf message corresponding to the TradeState enum.\n    \"\"\"\n    return self.value\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.UpdateOrder","title":"frequenz.client.electricity_trading.UpdateOrder  <code>dataclass</code>","text":"<p>Represents the order properties that can be updated after an order has been placed.</p> <p>At least one of the optional fields must be set for an update to take place.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>@dataclass()\nclass UpdateOrder:  # pylint: disable=too-many-instance-attributes\n    \"\"\"\n    Represents the order properties that can be updated after an order has been placed.\n\n    At least one of the optional fields must be set for an update to take place.\n    \"\"\"\n\n    price: Price | None = None\n    \"\"\"The updated limit price at which the contract is to be traded.\n    This is the maximum price for a BUY order or the minimum price for a SELL order.\"\"\"\n\n    quantity: Power | None = None\n    \"\"\"The updated quantity of the contract being traded, specified in MW.\"\"\"\n\n    stop_price: Price | None = None\n    \"\"\"Applicable for STOP_LIMIT orders. This is the updated stop price that triggers\n    the limit order.\"\"\"\n\n    peak_price_delta: Price | None = None\n    \"\"\"Applicable for ICEBERG orders. This is the updated price difference\n    between the peak price and the limit price.\"\"\"\n\n    display_quantity: Power | None = None\n    \"\"\"Applicable for ICEBERG orders. This is the updated quantity of the order\n    to be displayed in the order book.\"\"\"\n\n    execution_option: OrderExecutionOption | None = None\n    \"\"\"Updated execution options such as All or None, Fill or Kill, etc.\"\"\"\n\n    valid_until: datetime | None = None\n    \"\"\"This is an updated timestamp defining the time after which the order should\n    be cancelled if not filled. The timestamp is in UTC.\"\"\"\n\n    payload: dict[str, struct_pb2.Value] | None = None\n    \"\"\"Updated user-defined payload individual to a specific order. This can be any data\n    that the user wants to associate with the order.\"\"\"\n\n    tag: str | None = None\n    \"\"\"Updated user-defined tag to group related orders.\"\"\"\n\n    def __post_init__(self) -&gt; None:\n        \"\"\"Post initialization checks to ensure that all datetimes are UTC.\"\"\"\n        if self.valid_until is not None:\n            if self.valid_until.tzinfo is None:\n                raise ValueError(\"Valid until must be a UTC datetime.\")\n            if self.valid_until.tzinfo != timezone.utc:\n                _logger.warning(\"Valid until is not a UTC datetime. Converting to UTC.\")\n                self.valid_until = self.valid_until.astimezone(timezone.utc)\n\n    @classmethod\n    def from_pb(\n        cls,\n        update_order: electricity_trading_pb2.UpdateGridpoolOrderRequest.UpdateOrder,\n    ) -&gt; Self:\n        \"\"\"Convert a protobuf UpdateOrder to UpdateOrder object.\n\n        Args:\n            update_order: UpdateOrder to convert.\n\n        Returns:\n            UpdateOrder object corresponding to the protobuf message.\n        \"\"\"\n        return cls(\n            price=(\n                Price.from_pb(update_order.price)\n                if update_order.HasField(\"price\")\n                else None\n            ),\n            quantity=(\n                Power.from_pb(update_order.quantity)\n                if update_order.HasField(\"quantity\")\n                else None\n            ),\n            stop_price=(\n                Price.from_pb(update_order.stop_price)\n                if update_order.HasField(\"stop_price\")\n                else None\n            ),\n            peak_price_delta=(\n                Price.from_pb(update_order.peak_price_delta)\n                if update_order.HasField(\"peak_price_delta\")\n                else None\n            ),\n            display_quantity=(\n                Power.from_pb(update_order.display_quantity)\n                if update_order.HasField(\"display_quantity\")\n                else None\n            ),\n            execution_option=(\n                OrderExecutionOption.from_pb(update_order.execution_option)\n                if update_order.HasField(\"execution_option\")\n                else None\n            ),\n            valid_until=(\n                update_order.valid_until.ToDatetime(tzinfo=timezone.utc)\n                if update_order.HasField(\"valid_until\")\n                else None\n            ),\n            payload=(\n                json_format.MessageToDict(update_order.payload)\n                if update_order.payload\n                else None\n            ),\n            tag=update_order.tag if update_order.HasField(\"tag\") else None,\n        )\n\n    def to_pb(self) -&gt; electricity_trading_pb2.UpdateGridpoolOrderRequest.UpdateOrder:\n        \"\"\"Convert a UpdateOrder object to protobuf UpdateOrder.\n\n        Returns:\n            Protobuf UpdateOrder corresponding to the object.\n        \"\"\"\n        if self.valid_until:\n            valid_until = timestamp_pb2.Timestamp()\n            valid_until.FromDatetime(self.valid_until)\n        else:\n            valid_until = None\n        return electricity_trading_pb2.UpdateGridpoolOrderRequest.UpdateOrder(\n            price=self.price.to_pb() if self.price else None,\n            quantity=self.quantity.to_pb() if self.quantity else None,\n            stop_price=self.stop_price.to_pb() if self.stop_price else None,\n            peak_price_delta=(\n                self.peak_price_delta.to_pb() if self.peak_price_delta else None\n            ),\n            display_quantity=(\n                self.display_quantity.to_pb() if self.display_quantity else None\n            ),\n            execution_option=(\n                electricity_trading_pb2.OrderExecutionOption.ValueType(\n                    self.execution_option.value\n                )\n                if self.execution_option\n                else None\n            ),\n            valid_until=valid_until if self.valid_until else None,\n            payload=struct_pb2.Struct(fields=self.payload) if self.payload else None,\n            tag=self.tag if self.tag else None,\n        )\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.UpdateOrder-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.UpdateOrder.display_quantity","title":"display_quantity  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>display_quantity: Power | None = None\n</code></pre> <p>Applicable for ICEBERG orders. This is the updated quantity of the order to be displayed in the order book.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.UpdateOrder.execution_option","title":"execution_option  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>execution_option: OrderExecutionOption | None = None\n</code></pre> <p>Updated execution options such as All or None, Fill or Kill, etc.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.UpdateOrder.payload","title":"payload  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>payload: dict[str, Value] | None = None\n</code></pre> <p>Updated user-defined payload individual to a specific order. This can be any data that the user wants to associate with the order.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.UpdateOrder.peak_price_delta","title":"peak_price_delta  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>peak_price_delta: Price | None = None\n</code></pre> <p>Applicable for ICEBERG orders. This is the updated price difference between the peak price and the limit price.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.UpdateOrder.price","title":"price  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>price: Price | None = None\n</code></pre> <p>The updated limit price at which the contract is to be traded. This is the maximum price for a BUY order or the minimum price for a SELL order.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.UpdateOrder.quantity","title":"quantity  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>quantity: Power | None = None\n</code></pre> <p>The updated quantity of the contract being traded, specified in MW.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.UpdateOrder.stop_price","title":"stop_price  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>stop_price: Price | None = None\n</code></pre> <p>Applicable for STOP_LIMIT orders. This is the updated stop price that triggers the limit order.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.UpdateOrder.tag","title":"tag  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tag: str | None = None\n</code></pre> <p>Updated user-defined tag to group related orders.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.UpdateOrder.valid_until","title":"valid_until  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>valid_until: datetime | None = None\n</code></pre> <p>This is an updated timestamp defining the time after which the order should be cancelled if not filled. The timestamp is in UTC.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.UpdateOrder-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.UpdateOrder.__post_init__","title":"__post_init__","text":"<pre><code>__post_init__() -&gt; None\n</code></pre> <p>Post initialization checks to ensure that all datetimes are UTC.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>def __post_init__(self) -&gt; None:\n    \"\"\"Post initialization checks to ensure that all datetimes are UTC.\"\"\"\n    if self.valid_until is not None:\n        if self.valid_until.tzinfo is None:\n            raise ValueError(\"Valid until must be a UTC datetime.\")\n        if self.valid_until.tzinfo != timezone.utc:\n            _logger.warning(\"Valid until is not a UTC datetime. Converting to UTC.\")\n            self.valid_until = self.valid_until.astimezone(timezone.utc)\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.UpdateOrder.from_pb","title":"from_pb  <code>classmethod</code>","text":"<pre><code>from_pb(update_order: UpdateOrder) -&gt; Self\n</code></pre> <p>Convert a protobuf UpdateOrder to UpdateOrder object.</p> PARAMETER DESCRIPTION <code>update_order</code> <p>UpdateOrder to convert.</p> <p> TYPE: <code>UpdateOrder</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>UpdateOrder object corresponding to the protobuf message.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>@classmethod\ndef from_pb(\n    cls,\n    update_order: electricity_trading_pb2.UpdateGridpoolOrderRequest.UpdateOrder,\n) -&gt; Self:\n    \"\"\"Convert a protobuf UpdateOrder to UpdateOrder object.\n\n    Args:\n        update_order: UpdateOrder to convert.\n\n    Returns:\n        UpdateOrder object corresponding to the protobuf message.\n    \"\"\"\n    return cls(\n        price=(\n            Price.from_pb(update_order.price)\n            if update_order.HasField(\"price\")\n            else None\n        ),\n        quantity=(\n            Power.from_pb(update_order.quantity)\n            if update_order.HasField(\"quantity\")\n            else None\n        ),\n        stop_price=(\n            Price.from_pb(update_order.stop_price)\n            if update_order.HasField(\"stop_price\")\n            else None\n        ),\n        peak_price_delta=(\n            Price.from_pb(update_order.peak_price_delta)\n            if update_order.HasField(\"peak_price_delta\")\n            else None\n        ),\n        display_quantity=(\n            Power.from_pb(update_order.display_quantity)\n            if update_order.HasField(\"display_quantity\")\n            else None\n        ),\n        execution_option=(\n            OrderExecutionOption.from_pb(update_order.execution_option)\n            if update_order.HasField(\"execution_option\")\n            else None\n        ),\n        valid_until=(\n            update_order.valid_until.ToDatetime(tzinfo=timezone.utc)\n            if update_order.HasField(\"valid_until\")\n            else None\n        ),\n        payload=(\n            json_format.MessageToDict(update_order.payload)\n            if update_order.payload\n            else None\n        ),\n        tag=update_order.tag if update_order.HasField(\"tag\") else None,\n    )\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.UpdateOrder.to_pb","title":"to_pb","text":"<pre><code>to_pb() -&gt; UpdateOrder\n</code></pre> <p>Convert a UpdateOrder object to protobuf UpdateOrder.</p> RETURNS DESCRIPTION <code>UpdateOrder</code> <p>Protobuf UpdateOrder corresponding to the object.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>def to_pb(self) -&gt; electricity_trading_pb2.UpdateGridpoolOrderRequest.UpdateOrder:\n    \"\"\"Convert a UpdateOrder object to protobuf UpdateOrder.\n\n    Returns:\n        Protobuf UpdateOrder corresponding to the object.\n    \"\"\"\n    if self.valid_until:\n        valid_until = timestamp_pb2.Timestamp()\n        valid_until.FromDatetime(self.valid_until)\n    else:\n        valid_until = None\n    return electricity_trading_pb2.UpdateGridpoolOrderRequest.UpdateOrder(\n        price=self.price.to_pb() if self.price else None,\n        quantity=self.quantity.to_pb() if self.quantity else None,\n        stop_price=self.stop_price.to_pb() if self.stop_price else None,\n        peak_price_delta=(\n            self.peak_price_delta.to_pb() if self.peak_price_delta else None\n        ),\n        display_quantity=(\n            self.display_quantity.to_pb() if self.display_quantity else None\n        ),\n        execution_option=(\n            electricity_trading_pb2.OrderExecutionOption.ValueType(\n                self.execution_option.value\n            )\n            if self.execution_option\n            else None\n        ),\n        valid_until=valid_until if self.valid_until else None,\n        payload=struct_pb2.Struct(fields=self.payload) if self.payload else None,\n        tag=self.tag if self.tag else None,\n    )\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/cli/","title":"Index","text":""},{"location":"reference/frequenz/client/electricity_trading/cli/#frequenz.client.electricity_trading.cli","title":"frequenz.client.electricity_trading.cli","text":"<p>Package for CLI tool to interact with the trading API.</p>"},{"location":"reference/frequenz/client/electricity_trading/cli/day_ahead/","title":"day_ahead","text":""},{"location":"reference/frequenz/client/electricity_trading/cli/day_ahead/#frequenz.client.electricity_trading.cli.day_ahead","title":"frequenz.client.electricity_trading.cli.day_ahead","text":"<p>Functions for CLI tool to interact with the trading API.</p>"},{"location":"reference/frequenz/client/electricity_trading/cli/day_ahead/#frequenz.client.electricity_trading.cli.day_ahead-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/electricity_trading/cli/day_ahead/#frequenz.client.electricity_trading.cli.day_ahead.list_day_ahead_prices","title":"frequenz.client.electricity_trading.cli.day_ahead.list_day_ahead_prices","text":"<pre><code>list_day_ahead_prices(\n    entsoe_key: str,\n    start: datetime,\n    end: datetime,\n    country_code: str,\n) -&gt; None\n</code></pre> <p>List day-ahead prices for a given country code.</p> PARAMETER DESCRIPTION <code>entsoe_key</code> <p>The API key for the Entsoe API</p> <p> TYPE: <code>str</code> </p> <code>start</code> <p>The start date of the query</p> <p> TYPE: <code>datetime</code> </p> <code>end</code> <p>The end date of the query</p> <p> TYPE: <code>datetime</code> </p> <code>country_code</code> <p>The country code for which to query the prices</p> <p> TYPE: <code>str</code> </p> Source code in <code>frequenz/client/electricity_trading/cli/day_ahead.py</code> <pre><code>def list_day_ahead_prices(\n    entsoe_key: str,\n    start: datetime,\n    end: datetime,\n    country_code: str,\n) -&gt; None:\n    \"\"\"\n    List day-ahead prices for a given country code.\n\n    Args:\n        entsoe_key: The API key for the Entsoe API\n        start: The start date of the query\n        end: The end date of the query\n        country_code: The country code for which to query the prices\n    \"\"\"\n    start_ts = pd.Timestamp(start)\n    end_ts = pd.Timestamp(end)\n\n    client = EntsoePandasClient(api_key=entsoe_key)\n    da_prices = client.query_day_ahead_prices(country_code, start=start_ts, end=end_ts)\n\n    da_prices.name = \"price\"\n    da_prices.index.name = \"timestamp\"\n\n    print(da_prices.to_csv())\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/cli/etrading/","title":"etrading","text":""},{"location":"reference/frequenz/client/electricity_trading/cli/etrading/#frequenz.client.electricity_trading.cli.etrading","title":"frequenz.client.electricity_trading.cli.etrading","text":"<p>CLI tool to interact with the trading API.</p>"},{"location":"reference/frequenz/client/electricity_trading/cli/etrading/#frequenz.client.electricity_trading.cli.etrading-classes","title":"Classes","text":""},{"location":"reference/frequenz/client/electricity_trading/cli/etrading/#frequenz.client.electricity_trading.cli.etrading-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/electricity_trading/cli/etrading/#frequenz.client.electricity_trading.cli.etrading.cancel_order","title":"frequenz.client.electricity_trading.cli.etrading.cancel_order  <code>async</code>","text":"<pre><code>cancel_order(\n    url: str,\n    key: str,\n    *,\n    gridpool_id: int,\n    order_id: int | None\n) -&gt; None\n</code></pre> <p>Cancel an order by order ID.</p> <p>If order_id is None, cancel all orders in the gridpool.</p> PARAMETER DESCRIPTION <code>url</code> <p>URL of the trading API.</p> <p> TYPE: <code>str</code> </p> <code>key</code> <p>API key.</p> <p> TYPE: <code>str</code> </p> <code>gridpool_id</code> <p>Gridpool ID.</p> <p> TYPE: <code>int</code> </p> <code>order_id</code> <p>Order ID to cancel or None to cancel all orders.</p> <p> TYPE: <code>int | None</code> </p> Source code in <code>frequenz/client/electricity_trading/cli/etrading.py</code> <pre><code>async def cancel_order(\n    url: str, key: str, *, gridpool_id: int, order_id: int | None\n) -&gt; None:\n    \"\"\"Cancel an order by order ID.\n\n    If order_id is None, cancel all orders in the gridpool.\n\n    Args:\n        url: URL of the trading API.\n        key: API key.\n        gridpool_id: Gridpool ID.\n        order_id: Order ID to cancel or None to cancel all orders.\n    \"\"\"\n    client = Client(server_url=url, auth_key=key)\n    if order_id is None:\n        await client.cancel_all_gridpool_orders(gridpool_id)\n    else:\n        await client.cancel_gridpool_order(gridpool_id, order_id)\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/cli/etrading/#frequenz.client.electricity_trading.cli.etrading.check_delivery_start","title":"frequenz.client.electricity_trading.cli.etrading.check_delivery_start","text":"<pre><code>check_delivery_start(\n    ts: datetime,\n    duration: timedelta = timedelta(minutes=15),\n) -&gt; None\n</code></pre> <p>Validate that the delivery start is a multiple of duration.</p> PARAMETER DESCRIPTION <code>ts</code> <p>Delivery start timestamp.</p> <p> TYPE: <code>datetime</code> </p> <code>duration</code> <p>Delivery period duration.</p> <p> TYPE: <code>timedelta</code> DEFAULT: <code>timedelta(minutes=15)</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If <code>ts</code> is not a multiple of <code>duration</code>.</p> Source code in <code>frequenz/client/electricity_trading/cli/etrading.py</code> <pre><code>def check_delivery_start(\n    ts: datetime, duration: timedelta = timedelta(minutes=15)\n) -&gt; None:\n    \"\"\"Validate that the delivery start is a multiple of duration.\n\n    Args:\n        ts: Delivery start timestamp.\n        duration: Delivery period duration.\n\n    Raises:\n        ValueError: If `ts` is not a multiple of `duration`.\n    \"\"\"\n    if int(ts.timestamp()) % int(duration.total_seconds()) != 0:\n        raise ValueError(\"Delivery period must be a multiple of `duration`.\")\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/cli/etrading/#frequenz.client.electricity_trading.cli.etrading.create_order","title":"frequenz.client.electricity_trading.cli.etrading.create_order  <code>async</code>","text":"<pre><code>create_order(\n    url: str,\n    key: str,\n    *,\n    gid: int,\n    delivery_start: datetime,\n    delivery_area: str,\n    price: str,\n    quantity_mw: str,\n    currency: str,\n    duration: timedelta\n) -&gt; None\n</code></pre> <p>Create a limit order for a given price and quantity (in MW).</p> <p>The market side is determined by the sign of the quantity, positive for buy orders and negative for sell orders. The delivery area code is expected to be in EUROPE_EIC format.</p> PARAMETER DESCRIPTION <code>url</code> <p>URL of the trading API.</p> <p> TYPE: <code>str</code> </p> <code>key</code> <p>API key.</p> <p> TYPE: <code>str</code> </p> <code>gid</code> <p>Gridpool ID.</p> <p> TYPE: <code>int</code> </p> <code>delivery_start</code> <p>Start of the delivery period.</p> <p> TYPE: <code>datetime</code> </p> <code>delivery_area</code> <p>Delivery area code.</p> <p> TYPE: <code>str</code> </p> <code>price</code> <p>Price of the order.</p> <p> TYPE: <code>str</code> </p> <code>quantity_mw</code> <p>Quantity in MW, positive for buy orders and negative for sell orders.</p> <p> TYPE: <code>str</code> </p> <code>currency</code> <p>Currency of the price.</p> <p> TYPE: <code>str</code> </p> <code>duration</code> <p>Duration of the delivery period.</p> <p> TYPE: <code>timedelta</code> </p> Source code in <code>frequenz/client/electricity_trading/cli/etrading.py</code> <pre><code>async def create_order(\n    url: str,\n    key: str,\n    *,\n    gid: int,\n    delivery_start: datetime,\n    delivery_area: str,\n    price: str,\n    quantity_mw: str,\n    currency: str,\n    duration: timedelta,\n) -&gt; None:\n    \"\"\"Create a limit order for a given price and quantity (in MW).\n\n    The market side is determined by the sign of the quantity, positive for buy orders\n    and negative for sell orders. The delivery area code is expected to be in\n    EUROPE_EIC format.\n\n    Args:\n        url: URL of the trading API.\n        key: API key.\n        gid: Gridpool ID.\n        delivery_start: Start of the delivery period.\n        delivery_area: Delivery area code.\n        price: Price of the order.\n        quantity_mw: Quantity in MW, positive for buy orders and negative for sell orders.\n        currency: Currency of the price.\n        duration: Duration of the delivery period.\n    \"\"\"\n    client = Client(server_url=url, auth_key=key)\n\n    side = MarketSide.SELL if quantity_mw[0] == \"-\" else MarketSide.BUY\n    quantity = Power(mw=Decimal(quantity_mw.lstrip(\"-\")))\n    check_delivery_start(delivery_start)\n    order = await client.create_gridpool_order(\n        gridpool_id=gid,\n        delivery_area=DeliveryArea(\n            code=delivery_area,\n            code_type=EnergyMarketCodeType.EUROPE_EIC,\n        ),\n        delivery_period=DeliveryPeriod(\n            start=delivery_start,\n            duration=duration,\n        ),\n        order_type=OrderType.LIMIT,\n        side=side,\n        price=Price(\n            amount=Decimal(price),\n            currency=Currency[currency],\n        ),\n        quantity=quantity,\n    )\n\n    print_order(order)\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/cli/etrading/#frequenz.client.electricity_trading.cli.etrading.list_orders","title":"frequenz.client.electricity_trading.cli.etrading.list_orders  <code>async</code>","text":"<pre><code>list_orders(\n    url: str,\n    key: str,\n    *,\n    delivery_start: datetime,\n    gid: int\n) -&gt; None\n</code></pre> <p>List orders and stream new orders.</p> <p>If delivery_start is provided, list historical orders and stream new orders for the 15 minute delivery period starting at delivery_start. If no delivery_start is provided, stream new orders for any delivery period.</p> <p>Note that retrieved sort order for listed orders (starting from the newest) is reversed in chunks trying to bring more recent orders to the bottom.</p> PARAMETER DESCRIPTION <code>url</code> <p>URL of the trading API.</p> <p> TYPE: <code>str</code> </p> <code>key</code> <p>API key.</p> <p> TYPE: <code>str</code> </p> <code>delivery_start</code> <p>Start of the delivery period or None.</p> <p> TYPE: <code>datetime</code> </p> <code>gid</code> <p>Gridpool ID.</p> <p> TYPE: <code>int</code> </p> Source code in <code>frequenz/client/electricity_trading/cli/etrading.py</code> <pre><code>async def list_orders(\n    url: str, key: str, *, delivery_start: datetime, gid: int\n) -&gt; None:\n    \"\"\"List orders and stream new orders.\n\n    If delivery_start is provided, list historical orders and stream new orders\n    for the 15 minute delivery period starting at delivery_start.\n    If no delivery_start is provided, stream new orders for any delivery period.\n\n    Note that retrieved sort order for listed orders (starting from the newest)\n    is reversed in chunks trying to bring more recent orders to the bottom.\n\n    Args:\n        url: URL of the trading API.\n        key: API key.\n        delivery_start: Start of the delivery period or None.\n        gid: Gridpool ID.\n    \"\"\"\n    client = Client(server_url=url, auth_key=key)\n\n    # print_header()\n\n    delivery_period = None\n    # If delivery period is selected, list historical orders also\n    if delivery_start is not None:\n        check_delivery_start(delivery_start)\n        delivery_period = DeliveryPeriod(\n            start=delivery_start,\n            duration=timedelta(minutes=15),\n        )\n    lst = client.list_gridpool_orders(gid, delivery_period=delivery_period)\n\n    async for order in reverse_iterator(lst):\n        print_order(order)\n\n    if delivery_start and delivery_start &lt;= datetime.now(timezone.utc):\n        return\n\n    stream = await client.stream_gridpool_orders(gid, delivery_period=delivery_period)\n    async for order in stream:\n        print_order(order)\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/cli/etrading/#frequenz.client.electricity_trading.cli.etrading.list_trades","title":"frequenz.client.electricity_trading.cli.etrading.list_trades  <code>async</code>","text":"<pre><code>list_trades(\n    url: str, key: str, *, delivery_start: datetime\n) -&gt; None\n</code></pre> <p>List trades and stream new trades.</p> <p>If delivery_start is provided, list historical trades and stream new trades for the 15 minute delivery period starting at delivery_start. If no delivery_start is provided, stream new trades for any delivery period.</p> PARAMETER DESCRIPTION <code>url</code> <p>URL of the trading API.</p> <p> TYPE: <code>str</code> </p> <code>key</code> <p>API key.</p> <p> TYPE: <code>str</code> </p> <code>delivery_start</code> <p>Start of the delivery period or None.</p> <p> TYPE: <code>datetime</code> </p> Source code in <code>frequenz/client/electricity_trading/cli/etrading.py</code> <pre><code>async def list_trades(url: str, key: str, *, delivery_start: datetime) -&gt; None:\n    \"\"\"List trades and stream new trades.\n\n    If delivery_start is provided, list historical trades and stream new trades\n    for the 15 minute delivery period starting at delivery_start.\n    If no delivery_start is provided, stream new trades for any delivery period.\n\n    Args:\n        url: URL of the trading API.\n        key: API key.\n        delivery_start: Start of the delivery period or None.\n    \"\"\"\n    client = Client(server_url=url, auth_key=key)\n\n    print_trade_header()\n\n    delivery_period = None\n    # If delivery period is selected, list historical trades also\n    if delivery_start is not None:\n        check_delivery_start(delivery_start)\n        delivery_period = DeliveryPeriod(\n            start=delivery_start,\n            duration=timedelta(minutes=15),\n        )\n        lst = client.list_public_trades(delivery_period=delivery_period)\n\n        async for trade in lst:\n            print_trade(trade)\n\n        if delivery_start &lt;= datetime.now(timezone.utc):\n            return\n\n    stream = await client.stream_public_trades(delivery_period=delivery_period)\n    async for trade in stream:\n        print_trade(trade)\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/cli/etrading/#frequenz.client.electricity_trading.cli.etrading.print_order","title":"frequenz.client.electricity_trading.cli.etrading.print_order","text":"<pre><code>print_order(order: OrderDetail) -&gt; None\n</code></pre> <p>Print order details to stdout in CSV format.</p> <p>All fields except the following are printed: - order.stop_price - order.peak_price_delta - order.display_quantity - order.execution_option - order.valid_until - order.payload - order.tag - state_detail.state_reason - state_detail.market_actor - filled_quantity</p> PARAMETER DESCRIPTION <code>order</code> <p>OrderDetail object</p> <p> TYPE: <code>OrderDetail</code> </p> Source code in <code>frequenz/client/electricity_trading/cli/etrading.py</code> <pre><code>def print_order(order: OrderDetail) -&gt; None:\n    \"\"\"\n    Print order details to stdout in CSV format.\n\n    All fields except the following are printed:\n    - order.stop_price\n    - order.peak_price_delta\n    - order.display_quantity\n    - order.execution_option\n    - order.valid_until\n    - order.payload\n    - order.tag\n    - state_detail.state_reason\n    - state_detail.market_actor\n    - filled_quantity\n\n    Args:\n        order: OrderDetail object\n    \"\"\"\n    values = [\n        order.order_id,\n        order.create_time.isoformat(),\n        order.modification_time.isoformat(),\n        order.order.delivery_period.start.isoformat(),\n        order.order.delivery_period.duration,\n        order.order.delivery_area.code,\n        order.order.delivery_area.code_type,\n        order.order.type,\n        order.order.quantity.mw,\n        order.open_quantity.mw,\n        order.order.side,\n        order.order.price.currency,\n        order.order.price.amount,\n        order.state_detail.state,\n    ]\n    print(\",\".join(v.name if isinstance(v, Enum) else str(v) for v in values))\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/cli/etrading/#frequenz.client.electricity_trading.cli.etrading.print_order_header","title":"frequenz.client.electricity_trading.cli.etrading.print_order_header","text":"<pre><code>print_order_header() -&gt; None\n</code></pre> <p>Print order header in CSV format.</p> Source code in <code>frequenz/client/electricity_trading/cli/etrading.py</code> <pre><code>def print_order_header() -&gt; None:\n    \"\"\"Print order header in CSV format.\"\"\"\n    header = (\n        \"order_id, \"\n        \"create_time, \"\n        \"modification_time, \"\n        \"delivery_period_start, \"\n        \"delivery_period_duration\"\n        \"delivery_area_code, \"\n        \"delivery_area_code_type, \"\n        \"order_type, \"\n        \"quantity_mw, \"\n        \"open_quantity_mw, \"\n        \"side, \"\n        \"currency, \"\n        \"price, \"\n        \"state, \"\n    )\n    print(header)\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/cli/etrading/#frequenz.client.electricity_trading.cli.etrading.print_trade","title":"frequenz.client.electricity_trading.cli.etrading.print_trade","text":"<pre><code>print_trade(trade: PublicTrade) -&gt; None\n</code></pre> <p>Print trade details to stdout in CSV format.</p> Source code in <code>frequenz/client/electricity_trading/cli/etrading.py</code> <pre><code>def print_trade(trade: PublicTrade) -&gt; None:\n    \"\"\"Print trade details to stdout in CSV format.\"\"\"\n    values = (\n        trade.public_trade_id,\n        trade.execution_time.isoformat(),\n        trade.delivery_period.start.isoformat(),\n        trade.delivery_period.duration,\n        trade.buy_delivery_area.code,\n        trade.sell_delivery_area.code,\n        trade.buy_delivery_area.code_type,\n        trade.sell_delivery_area.code_type,\n        trade.quantity.mw,\n        trade.price.currency,\n        trade.price.amount,\n        trade.state,\n    )\n    print(\",\".join(v.name if isinstance(v, Enum) else str(v) for v in values))\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/cli/etrading/#frequenz.client.electricity_trading.cli.etrading.print_trade_header","title":"frequenz.client.electricity_trading.cli.etrading.print_trade_header","text":"<pre><code>print_trade_header() -&gt; None\n</code></pre> <p>Print trade header in CSV format.</p> Source code in <code>frequenz/client/electricity_trading/cli/etrading.py</code> <pre><code>def print_trade_header() -&gt; None:\n    \"\"\"Print trade header in CSV format.\"\"\"\n    header = (\n        \"public_trade_id, \"\n        \"execution_time, \"\n        \"delivery_period_start, \"\n        \"delivery_period_duration, \"\n        \"buy_delivery_area_code, \"\n        \"sell_delivery_area_code, \"\n        \"buy_delivery_area_code_type, \"\n        \"sell_delivery_area_code_type\"\n        \"quantity_mw, \"\n        \"price, \"\n        \"currency, \"\n        \"state, \"\n    )\n    print(header)\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/cli/etrading/#frequenz.client.electricity_trading.cli.etrading.reverse_iterator","title":"frequenz.client.electricity_trading.cli.etrading.reverse_iterator  <code>async</code>","text":"<pre><code>reverse_iterator(\n    iterator: AsyncIterator[OrderDetail],\n    chunk_size: int = 100000,\n) -&gt; AsyncIterator[OrderDetail]\n</code></pre> <p>Reverse an async iterator in chunks to avoid loading all elements into memory.</p> PARAMETER DESCRIPTION <code>iterator</code> <p>Async iterator to reverse.</p> <p> TYPE: <code>AsyncIterator[OrderDetail]</code> </p> <code>chunk_size</code> <p>Size of the buffer to store elements.</p> <p> TYPE: <code>int</code> DEFAULT: <code>100000</code> </p> YIELDS DESCRIPTION <code>AsyncIterator[OrderDetail]</code> <p>Elements of the iterator in reverse order.</p> Source code in <code>frequenz/client/electricity_trading/cli/etrading.py</code> <pre><code>async def reverse_iterator(\n    iterator: AsyncIterator[OrderDetail], chunk_size: int = 100_000\n) -&gt; AsyncIterator[OrderDetail]:\n    \"\"\"Reverse an async iterator in chunks to avoid loading all elements into memory.\n\n    Args:\n        iterator: Async iterator to reverse.\n        chunk_size: Size of the buffer to store elements.\n\n    Yields:\n        Elements of the iterator in reverse order.\n    \"\"\"\n    buffer: deque[OrderDetail] = deque(maxlen=chunk_size)\n    async for item in iterator:\n        buffer.append(item)\n        if len(buffer) == chunk_size:\n            for item in reversed(buffer):\n                yield item\n            buffer.clear()\n    if buffer:\n        for item in reversed(buffer):\n            yield item\n</code></pre>"}]}